{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Restricted Natural Language Compiler About the Project This project contains the source code for the compiler of the restricted natural language for automated web testing. The compiler generates a script for libraries such as Selenium (support for other libraries is coming soon) . Example Writing a library-agnostic script is straightforward. The primary goals of this language are: Write library-agnostic scripts easily Readable like plain English Robust tests with Smart Web Element Locators This simple script goes to the GitHub home page and tries to sign in with a dummy account. githubSignIn { visit \"https://github.com\" click link with description \"sign in present in the top right corner\" check if image with description \"GitHub logo\" is displayed type \"johndoe\" on input with description \"the username input field\" type \"secretpassword\" on input with description \"the password input filed\" click button with description \"sign in button\" } Grammar You can find below the LL(1) grammar of the language. program ::= test program | epsilon test ::= TEST_NAME { body } body ::= action body | epsilon action ::= click | check | type | visit elem_type ::= BUTTON | LINK | TEXT | IMAGE | INPUT visit ::= VISIT URL click ::= CLICK elem_type WITH_DESC NLD check ::= CHECK_IF elem_type WITH_DESC NLD state type ::= TYPE CONTENT ON elem_type WITH_DESC NLD state ::= DISPLAYED | HIDDEN UPPER_CASE refers to terminals, lower_case refers to non-terminals. We aim to support more actions in the future, however, the possible actions for the moment are: click, type (with visit and check being utility actions useful for testing) . Getting Started Installation Head to the releases page and download the latest release required version for your machine. Extract the executable from the archive and add it to your PATH environment variable if you wish to use it as a global CLI tool on your system. Using the compiler $ rnlc -i in.txt -o out.js -t selenium Compiled successfully CLI arguments $ rnlc --help Restricted Natural Language Compiler Usage: rnlc [OPTIONS] Options: -h,--help Print this help message and exit -i,--input TEXT REQUIRED Input file path -o,--output TEXT REQUIRED Output file path -t,--target TEXT:{json,selenium} [selenium] Output target (json, selenium) --keep-xpath [0] Keep XPATH instead of natural description (use this for testing purposes only)","title":"Home"},{"location":"#restricted-natural-language-compiler","text":"","title":"Restricted Natural Language Compiler"},{"location":"#about-the-project","text":"This project contains the source code for the compiler of the restricted natural language for automated web testing. The compiler generates a script for libraries such as Selenium (support for other libraries is coming soon) .","title":"About the Project"},{"location":"#example","text":"Writing a library-agnostic script is straightforward. The primary goals of this language are: Write library-agnostic scripts easily Readable like plain English Robust tests with Smart Web Element Locators This simple script goes to the GitHub home page and tries to sign in with a dummy account. githubSignIn { visit \"https://github.com\" click link with description \"sign in present in the top right corner\" check if image with description \"GitHub logo\" is displayed type \"johndoe\" on input with description \"the username input field\" type \"secretpassword\" on input with description \"the password input filed\" click button with description \"sign in button\" }","title":"Example"},{"location":"#grammar","text":"You can find below the LL(1) grammar of the language. program ::= test program | epsilon test ::= TEST_NAME { body } body ::= action body | epsilon action ::= click | check | type | visit elem_type ::= BUTTON | LINK | TEXT | IMAGE | INPUT visit ::= VISIT URL click ::= CLICK elem_type WITH_DESC NLD check ::= CHECK_IF elem_type WITH_DESC NLD state type ::= TYPE CONTENT ON elem_type WITH_DESC NLD state ::= DISPLAYED | HIDDEN UPPER_CASE refers to terminals, lower_case refers to non-terminals. We aim to support more actions in the future, however, the possible actions for the moment are: click, type (with visit and check being utility actions useful for testing) .","title":"Grammar"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#installation","text":"Head to the releases page and download the latest release required version for your machine. Extract the executable from the archive and add it to your PATH environment variable if you wish to use it as a global CLI tool on your system.","title":"Installation"},{"location":"#using-the-compiler","text":"$ rnlc -i in.txt -o out.js -t selenium Compiled successfully","title":"Using the compiler"},{"location":"#cli-arguments","text":"$ rnlc --help Restricted Natural Language Compiler Usage: rnlc [OPTIONS] Options: -h,--help Print this help message and exit -i,--input TEXT REQUIRED Input file path -o,--output TEXT REQUIRED Output file path -t,--target TEXT:{json,selenium} [selenium] Output target (json, selenium) --keep-xpath [0] Keep XPATH instead of natural description (use this for testing purposes only)","title":"CLI arguments"},{"location":"about/","text":"Struxisse dicet Iter suo Cumarum eminus genetrix in volucris Lorem markdownum mater luctantia ille, nec dixerat siquos virosque venenata resolvite lacerum et rursus. Admonet faciunt poenam quaesierat simulati urbem corpora in lenius, Areos spernitque bene sua invidiosa et herbas coepere. Nec hinc male, in cuncta mortis pietatis Caicum simul? Tibi parva, caput quo pugnat luminis, plenaque Troiane, quis similis messis adsuetos ignibus spicula partimque lege ! Nec votis, potuit, tene illo ultima! Leto membra purpureis miracula premens miseratus contingere pro. Ubi oras meritorum erat pretioque enim adeo prohibent Aurora densus. Genitor at suos repens nil victor mihi pectore unda lapidem hebetastis tu vivum si flagrantemque et at est. Mala Byblida. Nunc tergaque raptaque et lina a vellere magno. Ore late illic est suus, scelus relinquit placere! Sinistrae habes detulit Obscurus quam roboris, nec obest ventre tota interea nec, corpore non tibi redeuntia proxima animam! Decipere rerum tanta, caelum adductaque domus, haud livent parantis ultima lacertis nequiquam moverat. Populique angebar solent genus utrumque Ne nos templis auro secundo sontibus Terras tenvit hoc nihil confluat inopino magnasque Discumbere verbis Sed et iter simul igni Deos quae videre eum occidit vivere pomaque prensamque nisi culpa terga pando in magna: isse ramos te . Ensis de lympha. O magnae rubens circumdare unum agmina, sinu aequoreae ramos pennis manet, per sic . Venti virent piceis in dubito, rexque, mecum nec gemitum cum animam. Coniugis se parte , prius per corpus annis ; utque adflatuque. Dum accipe alto aut , ademi omnes in flammaque, forte. Dignabitur minoribus senior subnectite rogandos.","title":"Struxisse dicet"},{"location":"about/#struxisse-dicet","text":"","title":"Struxisse dicet"},{"location":"about/#iter-suo-cumarum-eminus-genetrix-in-volucris","text":"Lorem markdownum mater luctantia ille, nec dixerat siquos virosque venenata resolvite lacerum et rursus. Admonet faciunt poenam quaesierat simulati urbem corpora in lenius, Areos spernitque bene sua invidiosa et herbas coepere. Nec hinc male, in cuncta mortis pietatis Caicum simul? Tibi parva, caput quo pugnat luminis, plenaque Troiane, quis similis messis adsuetos ignibus spicula partimque lege ! Nec votis, potuit, tene illo ultima! Leto membra purpureis miracula premens miseratus contingere pro. Ubi oras meritorum erat pretioque enim adeo prohibent Aurora densus. Genitor at suos repens nil victor mihi pectore unda lapidem hebetastis tu vivum si flagrantemque et at est. Mala Byblida. Nunc tergaque raptaque et lina a vellere magno. Ore late illic est suus, scelus relinquit placere!","title":"Iter suo Cumarum eminus genetrix in volucris"},{"location":"about/#sinistrae-habes-detulit","text":"Obscurus quam roboris, nec obest ventre tota interea nec, corpore non tibi redeuntia proxima animam! Decipere rerum tanta, caelum adductaque domus, haud livent parantis ultima lacertis nequiquam moverat. Populique angebar solent genus utrumque Ne nos templis auro secundo sontibus Terras tenvit hoc nihil confluat inopino magnasque Discumbere verbis Sed et iter simul igni Deos quae videre eum occidit vivere pomaque prensamque nisi culpa terga pando in magna: isse ramos te . Ensis de lympha. O magnae rubens circumdare unum agmina, sinu aequoreae ramos pennis manet, per sic . Venti virent piceis in dubito, rexque, mecum nec gemitum cum animam. Coniugis se parte , prius per corpus annis ; utque adflatuque. Dum accipe alto aut , ademi omnes in flammaque, forte. Dignabitur minoribus senior subnectite rogandos.","title":"Sinistrae habes detulit"},{"location":"codegen/","text":"Adding a Code Generator Currently, our compiler supports generating code for the Selenium library. We also have the option to serialize the Abstract Syntax Tree (AST) to JSON. The Visitor Pattern Our implementation should be straightforward if you are already familiar with the Visitor design pattern. The JSON serializer is done though the JsonASTVisitor The Selenium codegen is done through the SeleniumASTVisitor Serialized AST with JSON The GitHub example present in the home page produces the following JSON output. This feature is useful if you aim to use this compiler within another project to represent this test visually as seen here . { \"tests\": [ { \"actions\": [ { \"type\": \"VisitNode\", \"url\": \"\\\"https://github.com\\\"\" }, { \"description\": \"\\\"sign in present in the top right corner\\\"\", \"element_type\": \"link\", \"type\": \"ClickNode\" }, { \"description\": \"\\\"GitHub logo\\\"\", \"element_type\": \"image\", \"state\": true, \"type\": \"CheckNode\" }, { \"content\": \"\\\"johndoe\\\"\", \"description\": \"\\\"the username input field\\\"\", \"element_type\": \"input\", \"type\": \"TypeNode\" }, { \"content\": \"\\\"secretpassword\\\"\", \"description\": \"\\\"the password input filed\\\"\", \"element_type\": \"input\", \"type\": \"TypeNode\" }, { \"description\": \"\\\"sign in button\\\"\", \"element_type\": \"button\", \"type\": \"ClickNode\" } ], \"testName\": \"githubSignIn\", \"type\": \"TestNode\" } ], \"type\": \"AST\" } Supporting a New Target To generate code for an unsupported library or format, you can create a new visitor class for your target which implements the ASTVisitor interface. To achieve this you have to implement the following functions: class ASTVisitor { public: virtual string visit(const VisitNode& node) = 0; virtual string visit(const ClickNode& node) = 0; virtual string visit(const TypeNode& node) = 0; virtual string visit(const CheckNode& node) = 0; virtual string visit(const TestNode& node) = 0; virtual string visit(const AST& tree) = 0; };","title":"Adding a Code Generator"},{"location":"codegen/#adding-a-code-generator","text":"Currently, our compiler supports generating code for the Selenium library. We also have the option to serialize the Abstract Syntax Tree (AST) to JSON.","title":"Adding a Code Generator"},{"location":"codegen/#the-visitor-pattern","text":"Our implementation should be straightforward if you are already familiar with the Visitor design pattern. The JSON serializer is done though the JsonASTVisitor The Selenium codegen is done through the SeleniumASTVisitor","title":"The Visitor Pattern"},{"location":"codegen/#serialized-ast-with-json","text":"The GitHub example present in the home page produces the following JSON output. This feature is useful if you aim to use this compiler within another project to represent this test visually as seen here . { \"tests\": [ { \"actions\": [ { \"type\": \"VisitNode\", \"url\": \"\\\"https://github.com\\\"\" }, { \"description\": \"\\\"sign in present in the top right corner\\\"\", \"element_type\": \"link\", \"type\": \"ClickNode\" }, { \"description\": \"\\\"GitHub logo\\\"\", \"element_type\": \"image\", \"state\": true, \"type\": \"CheckNode\" }, { \"content\": \"\\\"johndoe\\\"\", \"description\": \"\\\"the username input field\\\"\", \"element_type\": \"input\", \"type\": \"TypeNode\" }, { \"content\": \"\\\"secretpassword\\\"\", \"description\": \"\\\"the password input filed\\\"\", \"element_type\": \"input\", \"type\": \"TypeNode\" }, { \"description\": \"\\\"sign in button\\\"\", \"element_type\": \"button\", \"type\": \"ClickNode\" } ], \"testName\": \"githubSignIn\", \"type\": \"TestNode\" } ], \"type\": \"AST\" }","title":"Serialized AST with JSON"},{"location":"codegen/#supporting-a-new-target","text":"To generate code for an unsupported library or format, you can create a new visitor class for your target which implements the ASTVisitor interface. To achieve this you have to implement the following functions: class ASTVisitor { public: virtual string visit(const VisitNode& node) = 0; virtual string visit(const ClickNode& node) = 0; virtual string visit(const TypeNode& node) = 0; virtual string visit(const CheckNode& node) = 0; virtual string visit(const TestNode& node) = 0; virtual string visit(const AST& tree) = 0; };","title":"Supporting a New Target"},{"location":"hooks/","text":"Hooks Hooks are a way to inject information into the generated code by the compiler. This is typically useful when you would want to perform actions before or after a test runs. Note This is only available with Selenium targets API Reference beforeHook() Executes before the entire test suite finishes execution. beforeEachHook() Executes before each test finishes execution. afterHook() Executes after the entire test suite finishes execution. afterEachHook() Executes after each test finishes execution. getToken(): string Expose a Bearer (JWT) token to be used when talking with the LVLM server. getServerURL(): string Expose the LVLM server URL. afterEachAssertHook(message: string, passed: boolean) Executes after each check action. This is typically used to retrieve the results of the action and send them elsewhere.","title":"Hooks"},{"location":"hooks/#hooks","text":"Hooks are a way to inject information into the generated code by the compiler. This is typically useful when you would want to perform actions before or after a test runs. Note This is only available with Selenium targets","title":"Hooks"},{"location":"hooks/#api-reference","text":"","title":"API Reference"},{"location":"hooks/#beforehook","text":"Executes before the entire test suite finishes execution.","title":"beforeHook()"},{"location":"hooks/#beforeeachhook","text":"Executes before each test finishes execution.","title":"beforeEachHook()"},{"location":"hooks/#afterhook","text":"Executes after the entire test suite finishes execution.","title":"afterHook()"},{"location":"hooks/#aftereachhook","text":"Executes after each test finishes execution.","title":"afterEachHook()"},{"location":"hooks/#gettoken-string","text":"Expose a Bearer (JWT) token to be used when talking with the LVLM server.","title":"getToken(): string"},{"location":"hooks/#getserverurl-string","text":"Expose the LVLM server URL.","title":"getServerURL(): string"},{"location":"hooks/#aftereachasserthookmessage-string-passed-boolean","text":"Executes after each check action. This is typically used to retrieve the results of the action and send them elsewhere.","title":"afterEachAssertHook(message: string, passed: boolean)"},{"location":"nat-lang/","text":"Natural Language Descriptions Smart Web Element Locators Instead of relying on static locators such as XPATH, CSS classes or element IDs, the compiler identifies elements on a web page using a description of the element written in plain English (or Natural Language). This is achieved by an external Large Vision-Language Model (LVLM). Our implementation uses SeeClick to get a pair (x, y) of coordinates indicating the location of the element on the web page. SeeClick takes as input the image of the current web page as well as the description specified by the user. In this example, the NL description of the user is \"sign in present in the top right corner . This is passed along with a screenshot of the web page to SeeClick. It then resolves a pair of coordinates which can be used to move to this location and perform actions on the located element. click link with description \"sign in present in the top right corner\"","title":"Natural Language Descriptions"},{"location":"nat-lang/#natural-language-descriptions","text":"","title":"Natural Language Descriptions"},{"location":"nat-lang/#smart-web-element-locators","text":"Instead of relying on static locators such as XPATH, CSS classes or element IDs, the compiler identifies elements on a web page using a description of the element written in plain English (or Natural Language). This is achieved by an external Large Vision-Language Model (LVLM). Our implementation uses SeeClick to get a pair (x, y) of coordinates indicating the location of the element on the web page. SeeClick takes as input the image of the current web page as well as the description specified by the user. In this example, the NL description of the user is \"sign in present in the top right corner . This is passed along with a screenshot of the web page to SeeClick. It then resolves a pair of coordinates which can be used to move to this location and perform actions on the located element. click link with description \"sign in present in the top right corner\"","title":"Smart Web Element Locators"},{"location":"compiler/annotated/","text":"Class List Here are the classes, structs, unions and interfaces with brief descriptions: class AST class ASTVisitor class ActionNode class CheckNode class ClickNode class JsonASTVisitor class Scanner class SeleniumASTVisitor class TestNode class TypeNode class VisitNode struct lex_rule class parser namespace std","title":"Class List"},{"location":"compiler/annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: class AST class ASTVisitor class ActionNode class CheckNode class ClickNode class JsonASTVisitor class Scanner class SeleniumASTVisitor class TestNode class TypeNode class VisitNode struct lex_rule class parser namespace std","title":"Class List"},{"location":"compiler/files/","text":"File List Here is a list of all files with brief descriptions: dir src file parser.cpp file parser.h file scanner.cpp file scanner.h dir ast file AST.cpp file AST.h file JsonASTVisitor.cpp file JsonASTVisitor.h file SeleniumASTVisitor.cpp file SeleniumASTVisitor.h","title":"File List"},{"location":"compiler/files/#file-list","text":"Here is a list of all files with brief descriptions: dir src file parser.cpp file parser.h file scanner.cpp file scanner.h dir ast file AST.cpp file AST.h file JsonASTVisitor.cpp file JsonASTVisitor.h file SeleniumASTVisitor.cpp file SeleniumASTVisitor.h","title":"File List"},{"location":"compiler/classAST/","text":"Class AST ClassList > AST Public Attributes Type Name vector< TestNode > tests Public Functions Type Name AST (vector< TestNode > tests) AST () string accept ( ASTVisitor & visitor) const Public Attributes Documentation variable tests vector<TestNode> AST::tests; Public Functions Documentation function AST [1/2] explicit AST::AST ( vector< TestNode > tests ) function AST [2/2] explicit AST::AST () function accept string AST::accept ( ASTVisitor & visitor ) const The documentation for this class was generated from the following file src/ast/AST.h","title":"Class AST"},{"location":"compiler/classAST/#class-ast","text":"ClassList > AST","title":"Class AST"},{"location":"compiler/classAST/#public-attributes","text":"Type Name vector< TestNode > tests","title":"Public Attributes"},{"location":"compiler/classAST/#public-functions","text":"Type Name AST (vector< TestNode > tests) AST () string accept ( ASTVisitor & visitor) const","title":"Public Functions"},{"location":"compiler/classAST/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"compiler/classAST/#variable-tests","text":"vector<TestNode> AST::tests;","title":"variable tests"},{"location":"compiler/classAST/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classAST/#function-ast-12","text":"explicit AST::AST ( vector< TestNode > tests )","title":"function AST [1/2]"},{"location":"compiler/classAST/#function-ast-22","text":"explicit AST::AST ()","title":"function AST [2/2]"},{"location":"compiler/classAST/#function-accept","text":"string AST::accept ( ASTVisitor & visitor ) const The documentation for this class was generated from the following file src/ast/AST.h","title":"function accept"},{"location":"compiler/classASTVisitor/","text":"Class ASTVisitor ClassList > ASTVisitor Inherited by the following classes: JsonASTVisitor , SeleniumASTVisitor Public Functions Type Name virtual string visit (const VisitNode & node) = 0 virtual string visit (const ClickNode & node) = 0 virtual string visit (const TypeNode & node) = 0 virtual string visit (const CheckNode & node) = 0 virtual string visit (const TestNode & node) = 0 virtual string visit (const AST & tree) = 0 Public Functions Documentation function visit [1/6] virtual string ASTVisitor::visit ( const VisitNode & node ) = 0 function visit [2/6] virtual string ASTVisitor::visit ( const ClickNode & node ) = 0 function visit [3/6] virtual string ASTVisitor::visit ( const TypeNode & node ) = 0 function visit [4/6] virtual string ASTVisitor::visit ( const CheckNode & node ) = 0 function visit [5/6] virtual string ASTVisitor::visit ( const TestNode & node ) = 0 function visit [6/6] virtual string ASTVisitor::visit ( const AST & tree ) = 0 The documentation for this class was generated from the following file src/ast/AST.h","title":"Class ASTVisitor"},{"location":"compiler/classASTVisitor/#class-astvisitor","text":"ClassList > ASTVisitor Inherited by the following classes: JsonASTVisitor , SeleniumASTVisitor","title":"Class ASTVisitor"},{"location":"compiler/classASTVisitor/#public-functions","text":"Type Name virtual string visit (const VisitNode & node) = 0 virtual string visit (const ClickNode & node) = 0 virtual string visit (const TypeNode & node) = 0 virtual string visit (const CheckNode & node) = 0 virtual string visit (const TestNode & node) = 0 virtual string visit (const AST & tree) = 0","title":"Public Functions"},{"location":"compiler/classASTVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classASTVisitor/#function-visit-16","text":"virtual string ASTVisitor::visit ( const VisitNode & node ) = 0","title":"function visit [1/6]"},{"location":"compiler/classASTVisitor/#function-visit-26","text":"virtual string ASTVisitor::visit ( const ClickNode & node ) = 0","title":"function visit [2/6]"},{"location":"compiler/classASTVisitor/#function-visit-36","text":"virtual string ASTVisitor::visit ( const TypeNode & node ) = 0","title":"function visit [3/6]"},{"location":"compiler/classASTVisitor/#function-visit-46","text":"virtual string ASTVisitor::visit ( const CheckNode & node ) = 0","title":"function visit [4/6]"},{"location":"compiler/classASTVisitor/#function-visit-56","text":"virtual string ASTVisitor::visit ( const TestNode & node ) = 0","title":"function visit [5/6]"},{"location":"compiler/classASTVisitor/#function-visit-66","text":"virtual string ASTVisitor::visit ( const AST & tree ) = 0 The documentation for this class was generated from the following file src/ast/AST.h","title":"function visit [6/6]"},{"location":"compiler/classActionNode/","text":"Class ActionNode ClassList > ActionNode Inherited by the following classes: CheckNode , ClickNode , TypeNode , VisitNode Public Functions Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0 Public Functions Documentation function ActionNode ActionNode::ActionNode () = default function accept virtual string ActionNode::accept ( ASTVisitor & visitor ) const = 0 The documentation for this class was generated from the following file src/ast/AST.h","title":"Class ActionNode"},{"location":"compiler/classActionNode/#class-actionnode","text":"ClassList > ActionNode Inherited by the following classes: CheckNode , ClickNode , TypeNode , VisitNode","title":"Class ActionNode"},{"location":"compiler/classActionNode/#public-functions","text":"Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0","title":"Public Functions"},{"location":"compiler/classActionNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classActionNode/#function-actionnode","text":"ActionNode::ActionNode () = default","title":"function ActionNode"},{"location":"compiler/classActionNode/#function-accept","text":"virtual string ActionNode::accept ( ASTVisitor & visitor ) const = 0 The documentation for this class was generated from the following file src/ast/AST.h","title":"function accept"},{"location":"compiler/classCheckNode/","text":"Class CheckNode ClassList > CheckNode Inherits the following classes: ActionNode Public Functions Type Name CheckNode (string && element_type, string && description, bool state) virtual string accept ( ASTVisitor & visitor) override const string get_description () const string get_element_type () const bool get_state () const Public Functions inherited from ActionNode See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0 Public Functions Documentation function CheckNode explicit CheckNode::CheckNode ( string && element_type, string && description, bool state ) function accept virtual string CheckNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept function get_description string CheckNode::get_description () const function get_element_type string CheckNode::get_element_type () const function get_state bool CheckNode::get_state () const The documentation for this class was generated from the following file src/ast/AST.h","title":"Class CheckNode"},{"location":"compiler/classCheckNode/#class-checknode","text":"ClassList > CheckNode Inherits the following classes: ActionNode","title":"Class CheckNode"},{"location":"compiler/classCheckNode/#public-functions","text":"Type Name CheckNode (string && element_type, string && description, bool state) virtual string accept ( ASTVisitor & visitor) override const string get_description () const string get_element_type () const bool get_state () const","title":"Public Functions"},{"location":"compiler/classCheckNode/#public-functions-inherited-from-actionnode","text":"See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0","title":"Public Functions inherited from ActionNode"},{"location":"compiler/classCheckNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classCheckNode/#function-checknode","text":"explicit CheckNode::CheckNode ( string && element_type, string && description, bool state )","title":"function CheckNode"},{"location":"compiler/classCheckNode/#function-accept","text":"virtual string CheckNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept","title":"function accept"},{"location":"compiler/classCheckNode/#function-get_description","text":"string CheckNode::get_description () const","title":"function get_description"},{"location":"compiler/classCheckNode/#function-get_element_type","text":"string CheckNode::get_element_type () const","title":"function get_element_type"},{"location":"compiler/classCheckNode/#function-get_state","text":"bool CheckNode::get_state () const The documentation for this class was generated from the following file src/ast/AST.h","title":"function get_state"},{"location":"compiler/classClickNode/","text":"Class ClickNode ClassList > ClickNode Inherits the following classes: ActionNode Public Functions Type Name ClickNode (string && element_type, string && description) virtual string accept ( ASTVisitor & visitor) override const string get_description () const string get_element_type () const Public Functions inherited from ActionNode See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0 Public Functions Documentation function ClickNode explicit ClickNode::ClickNode ( string && element_type, string && description ) function accept virtual string ClickNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept function get_description string ClickNode::get_description () const function get_element_type string ClickNode::get_element_type () const The documentation for this class was generated from the following file src/ast/AST.h","title":"Class ClickNode"},{"location":"compiler/classClickNode/#class-clicknode","text":"ClassList > ClickNode Inherits the following classes: ActionNode","title":"Class ClickNode"},{"location":"compiler/classClickNode/#public-functions","text":"Type Name ClickNode (string && element_type, string && description) virtual string accept ( ASTVisitor & visitor) override const string get_description () const string get_element_type () const","title":"Public Functions"},{"location":"compiler/classClickNode/#public-functions-inherited-from-actionnode","text":"See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0","title":"Public Functions inherited from ActionNode"},{"location":"compiler/classClickNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classClickNode/#function-clicknode","text":"explicit ClickNode::ClickNode ( string && element_type, string && description )","title":"function ClickNode"},{"location":"compiler/classClickNode/#function-accept","text":"virtual string ClickNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept","title":"function accept"},{"location":"compiler/classClickNode/#function-get_description","text":"string ClickNode::get_description () const","title":"function get_description"},{"location":"compiler/classClickNode/#function-get_element_type","text":"string ClickNode::get_element_type () const The documentation for this class was generated from the following file src/ast/AST.h","title":"function get_element_type"},{"location":"compiler/classJsonASTVisitor/","text":"Class JsonASTVisitor ClassList > JsonASTVisitor Inherits the following classes: ASTVisitor Public Functions Type Name virtual string visit (const VisitNode & node) override virtual string visit (const ClickNode & node) override virtual string visit (const TypeNode & node) override virtual string visit (const CheckNode & node) override virtual string visit (const TestNode & node) override virtual string visit (const AST & tree) override Public Functions inherited from ASTVisitor See ASTVisitor Type Name virtual string visit (const VisitNode & node) = 0 virtual string visit (const ClickNode & node) = 0 virtual string visit (const TypeNode & node) = 0 virtual string visit (const CheckNode & node) = 0 virtual string visit (const TestNode & node) = 0 virtual string visit (const AST & tree) = 0 Public Functions Documentation function visit [1/6] virtual string JsonASTVisitor::visit ( const VisitNode & node ) override Implements ASTVisitor::visit function visit [2/6] virtual string JsonASTVisitor::visit ( const ClickNode & node ) override Implements ASTVisitor::visit function visit [3/6] virtual string JsonASTVisitor::visit ( const TypeNode & node ) override Implements ASTVisitor::visit function visit [4/6] virtual string JsonASTVisitor::visit ( const CheckNode & node ) override Implements ASTVisitor::visit function visit [5/6] virtual string JsonASTVisitor::visit ( const TestNode & node ) override Implements ASTVisitor::visit function visit [6/6] virtual string JsonASTVisitor::visit ( const AST & tree ) override Implements ASTVisitor::visit The documentation for this class was generated from the following file src/ast/JsonASTVisitor.h","title":"Class JsonASTVisitor"},{"location":"compiler/classJsonASTVisitor/#class-jsonastvisitor","text":"ClassList > JsonASTVisitor Inherits the following classes: ASTVisitor","title":"Class JsonASTVisitor"},{"location":"compiler/classJsonASTVisitor/#public-functions","text":"Type Name virtual string visit (const VisitNode & node) override virtual string visit (const ClickNode & node) override virtual string visit (const TypeNode & node) override virtual string visit (const CheckNode & node) override virtual string visit (const TestNode & node) override virtual string visit (const AST & tree) override","title":"Public Functions"},{"location":"compiler/classJsonASTVisitor/#public-functions-inherited-from-astvisitor","text":"See ASTVisitor Type Name virtual string visit (const VisitNode & node) = 0 virtual string visit (const ClickNode & node) = 0 virtual string visit (const TypeNode & node) = 0 virtual string visit (const CheckNode & node) = 0 virtual string visit (const TestNode & node) = 0 virtual string visit (const AST & tree) = 0","title":"Public Functions inherited from ASTVisitor"},{"location":"compiler/classJsonASTVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classJsonASTVisitor/#function-visit-16","text":"virtual string JsonASTVisitor::visit ( const VisitNode & node ) override Implements ASTVisitor::visit","title":"function visit [1/6]"},{"location":"compiler/classJsonASTVisitor/#function-visit-26","text":"virtual string JsonASTVisitor::visit ( const ClickNode & node ) override Implements ASTVisitor::visit","title":"function visit [2/6]"},{"location":"compiler/classJsonASTVisitor/#function-visit-36","text":"virtual string JsonASTVisitor::visit ( const TypeNode & node ) override Implements ASTVisitor::visit","title":"function visit [3/6]"},{"location":"compiler/classJsonASTVisitor/#function-visit-46","text":"virtual string JsonASTVisitor::visit ( const CheckNode & node ) override Implements ASTVisitor::visit","title":"function visit [4/6]"},{"location":"compiler/classJsonASTVisitor/#function-visit-56","text":"virtual string JsonASTVisitor::visit ( const TestNode & node ) override Implements ASTVisitor::visit","title":"function visit [5/6]"},{"location":"compiler/classJsonASTVisitor/#function-visit-66","text":"virtual string JsonASTVisitor::visit ( const AST & tree ) override Implements ASTVisitor::visit The documentation for this class was generated from the following file src/ast/JsonASTVisitor.h","title":"function visit [6/6]"},{"location":"compiler/classScanner/","text":"Class Scanner ClassList > Scanner Public Functions Type Name Scanner (string && content) int line_number () const int yylex () Public Static Functions Type Name string getTokenName (int tokenId) Public Functions Documentation function Scanner explicit Scanner::Scanner ( string && content ) function line_number int Scanner::line_number () const function yylex int Scanner::yylex () Public Static Functions Documentation function getTokenName static string Scanner::getTokenName ( int tokenId ) The documentation for this class was generated from the following file src/scanner.h","title":"Class Scanner"},{"location":"compiler/classScanner/#class-scanner","text":"ClassList > Scanner","title":"Class Scanner"},{"location":"compiler/classScanner/#public-functions","text":"Type Name Scanner (string && content) int line_number () const int yylex ()","title":"Public Functions"},{"location":"compiler/classScanner/#public-static-functions","text":"Type Name string getTokenName (int tokenId)","title":"Public Static Functions"},{"location":"compiler/classScanner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classScanner/#function-scanner","text":"explicit Scanner::Scanner ( string && content )","title":"function Scanner"},{"location":"compiler/classScanner/#function-line_number","text":"int Scanner::line_number () const","title":"function line_number"},{"location":"compiler/classScanner/#function-yylex","text":"int Scanner::yylex ()","title":"function yylex"},{"location":"compiler/classScanner/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"compiler/classScanner/#function-gettokenname","text":"static string Scanner::getTokenName ( int tokenId ) The documentation for this class was generated from the following file src/scanner.h","title":"function getTokenName"},{"location":"compiler/classSeleniumASTVisitor/","text":"Class SeleniumASTVisitor ClassList > SeleniumASTVisitor Inherits the following classes: ASTVisitor Public Functions Type Name SeleniumASTVisitor (bool keep_xpath) virtual string visit (const VisitNode & node) override virtual string visit (const ClickNode & node) override virtual string visit (const TypeNode & node) override virtual string visit (const CheckNode & node) override virtual string visit (const TestNode & node) override virtual string visit (const AST & tree) override Public Functions inherited from ASTVisitor See ASTVisitor Type Name virtual string visit (const VisitNode & node) = 0 virtual string visit (const ClickNode & node) = 0 virtual string visit (const TypeNode & node) = 0 virtual string visit (const CheckNode & node) = 0 virtual string visit (const TestNode & node) = 0 virtual string visit (const AST & tree) = 0 Public Functions Documentation function SeleniumASTVisitor inline explicit SeleniumASTVisitor::SeleniumASTVisitor ( bool keep_xpath ) function visit [1/6] virtual string SeleniumASTVisitor::visit ( const VisitNode & node ) override Implements ASTVisitor::visit function visit [2/6] virtual string SeleniumASTVisitor::visit ( const ClickNode & node ) override Implements ASTVisitor::visit function visit [3/6] virtual string SeleniumASTVisitor::visit ( const TypeNode & node ) override Implements ASTVisitor::visit function visit [4/6] virtual string SeleniumASTVisitor::visit ( const CheckNode & node ) override Implements ASTVisitor::visit function visit [5/6] virtual string SeleniumASTVisitor::visit ( const TestNode & node ) override Implements ASTVisitor::visit function visit [6/6] virtual string SeleniumASTVisitor::visit ( const AST & tree ) override Implements ASTVisitor::visit The documentation for this class was generated from the following file src/ast/SeleniumASTVisitor.h","title":"Class SeleniumASTVisitor"},{"location":"compiler/classSeleniumASTVisitor/#class-seleniumastvisitor","text":"ClassList > SeleniumASTVisitor Inherits the following classes: ASTVisitor","title":"Class SeleniumASTVisitor"},{"location":"compiler/classSeleniumASTVisitor/#public-functions","text":"Type Name SeleniumASTVisitor (bool keep_xpath) virtual string visit (const VisitNode & node) override virtual string visit (const ClickNode & node) override virtual string visit (const TypeNode & node) override virtual string visit (const CheckNode & node) override virtual string visit (const TestNode & node) override virtual string visit (const AST & tree) override","title":"Public Functions"},{"location":"compiler/classSeleniumASTVisitor/#public-functions-inherited-from-astvisitor","text":"See ASTVisitor Type Name virtual string visit (const VisitNode & node) = 0 virtual string visit (const ClickNode & node) = 0 virtual string visit (const TypeNode & node) = 0 virtual string visit (const CheckNode & node) = 0 virtual string visit (const TestNode & node) = 0 virtual string visit (const AST & tree) = 0","title":"Public Functions inherited from ASTVisitor"},{"location":"compiler/classSeleniumASTVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classSeleniumASTVisitor/#function-seleniumastvisitor","text":"inline explicit SeleniumASTVisitor::SeleniumASTVisitor ( bool keep_xpath )","title":"function SeleniumASTVisitor"},{"location":"compiler/classSeleniumASTVisitor/#function-visit-16","text":"virtual string SeleniumASTVisitor::visit ( const VisitNode & node ) override Implements ASTVisitor::visit","title":"function visit [1/6]"},{"location":"compiler/classSeleniumASTVisitor/#function-visit-26","text":"virtual string SeleniumASTVisitor::visit ( const ClickNode & node ) override Implements ASTVisitor::visit","title":"function visit [2/6]"},{"location":"compiler/classSeleniumASTVisitor/#function-visit-36","text":"virtual string SeleniumASTVisitor::visit ( const TypeNode & node ) override Implements ASTVisitor::visit","title":"function visit [3/6]"},{"location":"compiler/classSeleniumASTVisitor/#function-visit-46","text":"virtual string SeleniumASTVisitor::visit ( const CheckNode & node ) override Implements ASTVisitor::visit","title":"function visit [4/6]"},{"location":"compiler/classSeleniumASTVisitor/#function-visit-56","text":"virtual string SeleniumASTVisitor::visit ( const TestNode & node ) override Implements ASTVisitor::visit","title":"function visit [5/6]"},{"location":"compiler/classSeleniumASTVisitor/#function-visit-66","text":"virtual string SeleniumASTVisitor::visit ( const AST & tree ) override Implements ASTVisitor::visit The documentation for this class was generated from the following file src/ast/SeleniumASTVisitor.h","title":"function visit [6/6]"},{"location":"compiler/classTestNode/","text":"Class TestNode ClassList > TestNode Public Attributes Type Name vector< ActionNode * > actions string testName Public Functions Type Name TestNode (string && testName, vector< ActionNode * > actions) string accept ( ASTVisitor & visitor) const Public Attributes Documentation variable actions vector<ActionNode*> TestNode::actions; variable testName string TestNode::testName; Public Functions Documentation function TestNode explicit TestNode::TestNode ( string && testName, vector< ActionNode * > actions ) function accept string TestNode::accept ( ASTVisitor & visitor ) const The documentation for this class was generated from the following file src/ast/AST.h","title":"Class TestNode"},{"location":"compiler/classTestNode/#class-testnode","text":"ClassList > TestNode","title":"Class TestNode"},{"location":"compiler/classTestNode/#public-attributes","text":"Type Name vector< ActionNode * > actions string testName","title":"Public Attributes"},{"location":"compiler/classTestNode/#public-functions","text":"Type Name TestNode (string && testName, vector< ActionNode * > actions) string accept ( ASTVisitor & visitor) const","title":"Public Functions"},{"location":"compiler/classTestNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"compiler/classTestNode/#variable-actions","text":"vector<ActionNode*> TestNode::actions;","title":"variable actions"},{"location":"compiler/classTestNode/#variable-testname","text":"string TestNode::testName;","title":"variable testName"},{"location":"compiler/classTestNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classTestNode/#function-testnode","text":"explicit TestNode::TestNode ( string && testName, vector< ActionNode * > actions )","title":"function TestNode"},{"location":"compiler/classTestNode/#function-accept","text":"string TestNode::accept ( ASTVisitor & visitor ) const The documentation for this class was generated from the following file src/ast/AST.h","title":"function accept"},{"location":"compiler/classTypeNode/","text":"Class TypeNode ClassList > TypeNode Inherits the following classes: ActionNode Public Functions Type Name TypeNode (string && content, string && element_type, string && description) virtual string accept ( ASTVisitor & visitor) override const string get_content () const string get_description () const string get_element_type () const Public Functions inherited from ActionNode See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0 Public Functions Documentation function TypeNode explicit TypeNode::TypeNode ( string && content, string && element_type, string && description ) function accept virtual string TypeNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept function get_content string TypeNode::get_content () const function get_description string TypeNode::get_description () const function get_element_type string TypeNode::get_element_type () const The documentation for this class was generated from the following file src/ast/AST.h","title":"Class TypeNode"},{"location":"compiler/classTypeNode/#class-typenode","text":"ClassList > TypeNode Inherits the following classes: ActionNode","title":"Class TypeNode"},{"location":"compiler/classTypeNode/#public-functions","text":"Type Name TypeNode (string && content, string && element_type, string && description) virtual string accept ( ASTVisitor & visitor) override const string get_content () const string get_description () const string get_element_type () const","title":"Public Functions"},{"location":"compiler/classTypeNode/#public-functions-inherited-from-actionnode","text":"See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0","title":"Public Functions inherited from ActionNode"},{"location":"compiler/classTypeNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classTypeNode/#function-typenode","text":"explicit TypeNode::TypeNode ( string && content, string && element_type, string && description )","title":"function TypeNode"},{"location":"compiler/classTypeNode/#function-accept","text":"virtual string TypeNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept","title":"function accept"},{"location":"compiler/classTypeNode/#function-get_content","text":"string TypeNode::get_content () const","title":"function get_content"},{"location":"compiler/classTypeNode/#function-get_description","text":"string TypeNode::get_description () const","title":"function get_description"},{"location":"compiler/classTypeNode/#function-get_element_type","text":"string TypeNode::get_element_type () const The documentation for this class was generated from the following file src/ast/AST.h","title":"function get_element_type"},{"location":"compiler/classVisitNode/","text":"Class VisitNode ClassList > VisitNode Inherits the following classes: ActionNode Public Functions Type Name VisitNode (string && url) virtual string accept ( ASTVisitor & visitor) override const string get_url () const Public Functions inherited from ActionNode See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0 Public Functions Documentation function VisitNode explicit VisitNode::VisitNode ( string && url ) function accept virtual string VisitNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept function get_url inline string VisitNode::get_url () const The documentation for this class was generated from the following file src/ast/AST.h","title":"Class VisitNode"},{"location":"compiler/classVisitNode/#class-visitnode","text":"ClassList > VisitNode Inherits the following classes: ActionNode","title":"Class VisitNode"},{"location":"compiler/classVisitNode/#public-functions","text":"Type Name VisitNode (string && url) virtual string accept ( ASTVisitor & visitor) override const string get_url () const","title":"Public Functions"},{"location":"compiler/classVisitNode/#public-functions-inherited-from-actionnode","text":"See ActionNode Type Name ActionNode () = default virtual string accept ( ASTVisitor & visitor) const = 0","title":"Public Functions inherited from ActionNode"},{"location":"compiler/classVisitNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classVisitNode/#function-visitnode","text":"explicit VisitNode::VisitNode ( string && url )","title":"function VisitNode"},{"location":"compiler/classVisitNode/#function-accept","text":"virtual string VisitNode::accept ( ASTVisitor & visitor ) override const Implements ActionNode::accept","title":"function accept"},{"location":"compiler/classVisitNode/#function-get_url","text":"inline string VisitNode::get_url () const The documentation for this class was generated from the following file src/ast/AST.h","title":"function get_url"},{"location":"compiler/structlex__rule/","text":"Struct lex_rule ClassList > lex_rule Public Attributes Type Name function< int(const string &)> lambda string regex Public Attributes Documentation variable lambda function<int(const string&)> lex_rule::lambda; variable regex string lex_rule::regex; The documentation for this class was generated from the following file src/scanner.h","title":"Struct lex_rule"},{"location":"compiler/structlex__rule/#struct-lex_rule","text":"ClassList > lex_rule","title":"Struct lex_rule"},{"location":"compiler/structlex__rule/#public-attributes","text":"Type Name function< int(const string &)> lambda string regex","title":"Public Attributes"},{"location":"compiler/structlex__rule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"compiler/structlex__rule/#variable-lambda","text":"function<int(const string&)> lex_rule::lambda;","title":"variable lambda"},{"location":"compiler/structlex__rule/#variable-regex","text":"string lex_rule::regex; The documentation for this class was generated from the following file src/scanner.h","title":"variable regex"},{"location":"compiler/classparser/","text":"Class parser ClassList > parser Public Functions Type Name expected< AST , vector< string > > parse () parser (string && content) Public Functions Documentation function parse expected< AST , vector< string > > parser::parse () function parser explicit parser::parser ( string && content ) The documentation for this class was generated from the following file src/parser.h","title":"Class parser"},{"location":"compiler/classparser/#class-parser","text":"ClassList > parser","title":"Class parser"},{"location":"compiler/classparser/#public-functions","text":"Type Name expected< AST , vector< string > > parse () parser (string && content)","title":"Public Functions"},{"location":"compiler/classparser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"compiler/classparser/#function-parse","text":"expected< AST , vector< string > > parser::parse ()","title":"function parse"},{"location":"compiler/classparser/#function-parser","text":"explicit parser::parser ( string && content ) The documentation for this class was generated from the following file src/parser.h","title":"function parser"},{"location":"compiler/namespacestd/","text":"Namespace std Namespace List > std The documentation for this class was generated from the following file src/ast/AST.h","title":"Namespace std"},{"location":"compiler/namespacestd/#namespace-std","text":"Namespace List > std The documentation for this class was generated from the following file src/ast/AST.h","title":"Namespace std"},{"location":"compiler/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"Dir src FileList > src Files Type Name file parser.cpp file parser.h file scanner.cpp file scanner.h Directories Type Name dir ast The documentation for this class was generated from the following file src/","title":"Dir src"},{"location":"compiler/dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","text":"FileList > src","title":"Dir src"},{"location":"compiler/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Type Name file parser.cpp file parser.h file scanner.cpp file scanner.h","title":"Files"},{"location":"compiler/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Type Name dir ast The documentation for this class was generated from the following file src/","title":"Directories"},{"location":"compiler/parser_8cpp/","text":"File parser.cpp FileList > src > parser.cpp Go to the source code of this file #include \"parser.h\" #include \"ast/SeleniumASTVisitor.h\" The documentation for this class was generated from the following file src/parser.cpp","title":"File parser.cpp"},{"location":"compiler/parser_8cpp/#file-parsercpp","text":"FileList > src > parser.cpp Go to the source code of this file #include \"parser.h\" #include \"ast/SeleniumASTVisitor.h\" The documentation for this class was generated from the following file src/parser.cpp","title":"File parser.cpp"},{"location":"compiler/parser_8cpp_source/","text":"File parser.cpp File List > src > parser.cpp Go to the documentation of this file #include \"parser.h\" #include \"ast/SeleniumASTVisitor.h\" parser::parser(string&& content) : scanner { Scanner(std::move(content)) }, tree(AST()) {} bool parser::program() { //program -> test program | epsilon if(token == 0) return true; // program -> epsilon if(!test()) return false; if(!program()) return false; return true; // program -> test program } bool parser::test() { if(token == TEST_NAME) { tree.tests.emplace_back(std::move(yysval), vector<ActionNode*>()); token = scanner.yylex(); if(token == LEFT_BRACE) { token = scanner.yylex(); if(!body()){ return recoverFromError({TEST_NAME}); } if(token != RIGHT_BRACE) { reportError(\"RIGHT BRACE\"); return recoverFromError({TEST_NAME}); } }else{ reportError(\"LEFT BRACE\"); return recoverFromError({TEST_NAME}); } token = scanner.yylex(); return true; } reportError(\"TEST NAME\"); return recoverFromError({TEST_NAME}); } bool parser::action() { switch (token) { case CLICK: return click(); case HOVER_OVER: return hover(); case VISIT: return visit(); case TYPE: return type(); case CHECK_IF: return check(); default: return false; } } bool parser::visit() { if(token == VISIT) { token = scanner.yylex(); if(token != URL) { reportError(\"URL\"); return recoverFromError({CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}); } tree.tests.back().actions.push_back(new VisitNode(std::move(yysval))); token = scanner.yylex(); return true; } return false; } bool parser::body() { if(token == CLICK || token == HOVER_OVER || token == TYPE || token == CHECK_IF || token == VISIT) { return action() && body(); } return true; } bool parser::elem_type() { if(token == BUTTON || token == LINK || token == TEXT || token == IMAGE || token == INPUT){ token = scanner.yylex(); return true; } return false; } bool parser::click() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token == CLICK) { token = scanner.yylex(); string element_type = yysval; if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token == WITH_DESC) { token = scanner.yylex(); if(token != NLD) { reportError(\"NLD\"); return recoverFromError(recoveryTokens); } }else{ reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } tree.tests.back().actions.push_back(new ClickNode(std::move(element_type), std::move(yysval))); token = scanner.yylex(); return true; } return false; } bool parser::check() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token == CHECK_IF) { token = scanner.yylex(); string element_type = yysval; if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token == WITH_DESC) { token = scanner.yylex(); if(token != NLD){ reportError(\"NLD\"); return recoverFromError(recoveryTokens); } string xpath = yysval; token = scanner.yylex(); tree.tests.back().actions.push_back(new CheckNode(std::move(element_type), std::move(xpath), token == DISPLAYED)); if(state()){ return true; }else{ reportError(\"STATE\"); return recoverFromError(recoveryTokens); } }else{ reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } } return false; } bool parser::hover() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token == HOVER_OVER) { token = scanner.yylex(); if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token == WITH_DESC) { token = scanner.yylex(); if(token != NLD){ reportError(\"NLD\"); return recoverFromError(recoveryTokens); } } else { reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } token = scanner.yylex(); return true; } return false; } bool parser::type() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token != TYPE) return false; token = scanner.yylex(); if(token != NLD) { reportError(\"CONTENT\"); return recoverFromError(recoveryTokens); } // TODO: IT SHOULD BE CONTENT string content = yysval; token = scanner.yylex(); if(token != ON){ reportError(\"ON\"); return recoverFromError(recoveryTokens); } token = scanner.yylex(); string element_type = yysval; if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token != WITH_DESC){ reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } token = scanner.yylex(); if(token != NLD){ reportError(\"NLD\"); return recoverFromError(recoveryTokens); } tree.tests.back().actions.push_back(new TypeNode(std::move(content), std::move(element_type), std::move(yysval))); token = scanner.yylex(); return true; } bool parser::state() { if(token == DISPLAYED || token == HIDDEN) { token = scanner.yylex(); return true; } return false; } bool parser::recoverFromError(const vector<enum Tokens>& syncSet) { while (token != 0) { for (auto syncToken : syncSet) { if (token == syncToken) { cerr << \"[Recovery] Found synchronizing token: \" << Scanner::getTokenName(token) << \" at line \" << to_string(scanner.line_number()) << endl; return true; } } token = scanner.yylex(); } cerr << \"Failed to recover. Reached EOF.\\n\"; return false; } void parser::reportError(const string& expectedToken) { errors.push_back(\"Expected \" + expectedToken + \", but found \" + Scanner::getTokenName(token) + \" instead at line \" + std::to_string(scanner.line_number())); } expected<AST, vector<string>> parser::parse() { token = scanner.yylex(); if (program() && errors.empty()) { return tree; } return unexpected(errors); }","title":"File parser.cpp"},{"location":"compiler/parser_8cpp_source/#file-parsercpp","text":"File List > src > parser.cpp Go to the documentation of this file #include \"parser.h\" #include \"ast/SeleniumASTVisitor.h\" parser::parser(string&& content) : scanner { Scanner(std::move(content)) }, tree(AST()) {} bool parser::program() { //program -> test program | epsilon if(token == 0) return true; // program -> epsilon if(!test()) return false; if(!program()) return false; return true; // program -> test program } bool parser::test() { if(token == TEST_NAME) { tree.tests.emplace_back(std::move(yysval), vector<ActionNode*>()); token = scanner.yylex(); if(token == LEFT_BRACE) { token = scanner.yylex(); if(!body()){ return recoverFromError({TEST_NAME}); } if(token != RIGHT_BRACE) { reportError(\"RIGHT BRACE\"); return recoverFromError({TEST_NAME}); } }else{ reportError(\"LEFT BRACE\"); return recoverFromError({TEST_NAME}); } token = scanner.yylex(); return true; } reportError(\"TEST NAME\"); return recoverFromError({TEST_NAME}); } bool parser::action() { switch (token) { case CLICK: return click(); case HOVER_OVER: return hover(); case VISIT: return visit(); case TYPE: return type(); case CHECK_IF: return check(); default: return false; } } bool parser::visit() { if(token == VISIT) { token = scanner.yylex(); if(token != URL) { reportError(\"URL\"); return recoverFromError({CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}); } tree.tests.back().actions.push_back(new VisitNode(std::move(yysval))); token = scanner.yylex(); return true; } return false; } bool parser::body() { if(token == CLICK || token == HOVER_OVER || token == TYPE || token == CHECK_IF || token == VISIT) { return action() && body(); } return true; } bool parser::elem_type() { if(token == BUTTON || token == LINK || token == TEXT || token == IMAGE || token == INPUT){ token = scanner.yylex(); return true; } return false; } bool parser::click() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token == CLICK) { token = scanner.yylex(); string element_type = yysval; if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token == WITH_DESC) { token = scanner.yylex(); if(token != NLD) { reportError(\"NLD\"); return recoverFromError(recoveryTokens); } }else{ reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } tree.tests.back().actions.push_back(new ClickNode(std::move(element_type), std::move(yysval))); token = scanner.yylex(); return true; } return false; } bool parser::check() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token == CHECK_IF) { token = scanner.yylex(); string element_type = yysval; if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token == WITH_DESC) { token = scanner.yylex(); if(token != NLD){ reportError(\"NLD\"); return recoverFromError(recoveryTokens); } string xpath = yysval; token = scanner.yylex(); tree.tests.back().actions.push_back(new CheckNode(std::move(element_type), std::move(xpath), token == DISPLAYED)); if(state()){ return true; }else{ reportError(\"STATE\"); return recoverFromError(recoveryTokens); } }else{ reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } } return false; } bool parser::hover() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token == HOVER_OVER) { token = scanner.yylex(); if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token == WITH_DESC) { token = scanner.yylex(); if(token != NLD){ reportError(\"NLD\"); return recoverFromError(recoveryTokens); } } else { reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } token = scanner.yylex(); return true; } return false; } bool parser::type() { vector<Tokens> recoveryTokens = {CLICK, HOVER_OVER, VISIT, TYPE, CHECK_IF, RIGHT_BRACE}; if(token != TYPE) return false; token = scanner.yylex(); if(token != NLD) { reportError(\"CONTENT\"); return recoverFromError(recoveryTokens); } // TODO: IT SHOULD BE CONTENT string content = yysval; token = scanner.yylex(); if(token != ON){ reportError(\"ON\"); return recoverFromError(recoveryTokens); } token = scanner.yylex(); string element_type = yysval; if(!elem_type()){ reportError(\"ELEMENT TYPE\"); return recoverFromError(recoveryTokens); } if(token != WITH_DESC){ reportError(\"WITH DESCRIPTION\"); return recoverFromError(recoveryTokens); } token = scanner.yylex(); if(token != NLD){ reportError(\"NLD\"); return recoverFromError(recoveryTokens); } tree.tests.back().actions.push_back(new TypeNode(std::move(content), std::move(element_type), std::move(yysval))); token = scanner.yylex(); return true; } bool parser::state() { if(token == DISPLAYED || token == HIDDEN) { token = scanner.yylex(); return true; } return false; } bool parser::recoverFromError(const vector<enum Tokens>& syncSet) { while (token != 0) { for (auto syncToken : syncSet) { if (token == syncToken) { cerr << \"[Recovery] Found synchronizing token: \" << Scanner::getTokenName(token) << \" at line \" << to_string(scanner.line_number()) << endl; return true; } } token = scanner.yylex(); } cerr << \"Failed to recover. Reached EOF.\\n\"; return false; } void parser::reportError(const string& expectedToken) { errors.push_back(\"Expected \" + expectedToken + \", but found \" + Scanner::getTokenName(token) + \" instead at line \" + std::to_string(scanner.line_number())); } expected<AST, vector<string>> parser::parse() { token = scanner.yylex(); if (program() && errors.empty()) { return tree; } return unexpected(errors); }","title":"File parser.cpp"},{"location":"compiler/parser_8h/","text":"File parser.h FileList > src > parser.h Go to the source code of this file #include <string> #include <vector> #include <unordered_map> #include <expected> #include \"scanner.h\" #include \"ast/AST.h\" Classes Type Name class parser The documentation for this class was generated from the following file src/parser.h","title":"Parser"},{"location":"compiler/parser_8h/#file-parserh","text":"FileList > src > parser.h Go to the source code of this file #include <string> #include <vector> #include <unordered_map> #include <expected> #include \"scanner.h\" #include \"ast/AST.h\"","title":"File parser.h"},{"location":"compiler/parser_8h/#classes","text":"Type Name class parser The documentation for this class was generated from the following file src/parser.h","title":"Classes"},{"location":"compiler/parser_8h_source/","text":"File parser.h File List > src > parser.h Go to the documentation of this file // // Created by Ghady Youssef on 16/09/2024. // #ifndef RESTRICTED_NL_PARSER_H #define RESTRICTED_NL_PARSER_H #include <string> #include <vector> #include <unordered_map> #include <expected> #include \"scanner.h\" #include \"ast/AST.h\" using namespace std; class parser { private: vector<string> errors; Scanner scanner; int token {}; AST tree; bool program(); bool body(); bool action(); bool elem_type(); bool test(); bool visit(); bool click(); bool hover(); bool check(); bool type(); bool state(); bool recoverFromError(const vector<enum Tokens>&); void reportError(const string& expectedToken); public: explicit parser(string&& content); expected<AST, vector<string>> parse(); }; #endif //RESTRICTED_NL_PARSER_H","title":"File parser.h"},{"location":"compiler/parser_8h_source/#file-parserh","text":"File List > src > parser.h Go to the documentation of this file // // Created by Ghady Youssef on 16/09/2024. // #ifndef RESTRICTED_NL_PARSER_H #define RESTRICTED_NL_PARSER_H #include <string> #include <vector> #include <unordered_map> #include <expected> #include \"scanner.h\" #include \"ast/AST.h\" using namespace std; class parser { private: vector<string> errors; Scanner scanner; int token {}; AST tree; bool program(); bool body(); bool action(); bool elem_type(); bool test(); bool visit(); bool click(); bool hover(); bool check(); bool type(); bool state(); bool recoverFromError(const vector<enum Tokens>&); void reportError(const string& expectedToken); public: explicit parser(string&& content); expected<AST, vector<string>> parse(); }; #endif //RESTRICTED_NL_PARSER_H","title":"File parser.h"},{"location":"compiler/scanner_8cpp/","text":"File scanner.cpp FileList > src > scanner.cpp Go to the source code of this file #include \"scanner.h\" Public Attributes Type Name string yysval Public Attributes Documentation variable yysval string yysval; The documentation for this class was generated from the following file src/scanner.cpp","title":"File scanner.cpp"},{"location":"compiler/scanner_8cpp/#file-scannercpp","text":"FileList > src > scanner.cpp Go to the source code of this file #include \"scanner.h\"","title":"File scanner.cpp"},{"location":"compiler/scanner_8cpp/#public-attributes","text":"Type Name string yysval","title":"Public Attributes"},{"location":"compiler/scanner_8cpp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"compiler/scanner_8cpp/#variable-yysval","text":"string yysval; The documentation for this class was generated from the following file src/scanner.cpp","title":"variable yysval"},{"location":"compiler/scanner_8cpp_source/","text":"File scanner.cpp File List > src > scanner.cpp Go to the documentation of this file #include \"scanner.h\" string yysval; Scanner::Scanner(string&& content) : yyinput { content }, position { 0 }, token { 0ll } { if(content.empty()) return; rules = vector<lex_rule>({ {\"click\", [&](const string & s) { return CLICK;}}, {\"visit\", [&](const string & s) { return VISIT;}}, {\"button\", [&](const string & s) { yysval = s; return BUTTON;}}, {\"link\", [&](const string & s) { yysval = s; return LINK;}}, {\"text\", [&](const string & s) { yysval = s; return TEXT;}}, {\"input\", [&](const string & s) { yysval = s; return INPUT;}}, {\"image\", [&](const string & s) { yysval = s; return IMAGE;}}, {\"is displayed\", [&](const string & s) { return DISPLAYED;}}, {\"is hidden\", [&](const string & s) { return HIDDEN;}}, {\"check if\", [&](const string & s) { return CHECK_IF;}}, {\"with description\", [&](const string & s) { return WITH_DESC;}}, {\"hover over\", [&](const string & s) { return HOVER_OVER;}}, {\"on\", [&](const string & s) { return ON;}}, {\"type\", [&](const string & s) { return TYPE;}}, {\"[{]\", [&](const string & s) { return LEFT_BRACE;}}, {\"[}]\", [&](const string & s) { return RIGHT_BRACE;}}, {\"[\\\"]https://[a-zA-Z0-9./]*[\\\"]\", [&](const string & s) { yysval = s; return URL;}}, {\"[a-zA-Z][a-zA-Z0-9]*\", [&](const string & s) { yysval = s; return TEST_NAME;}}, {R\"([\"][a-zA-Z0-9 /@='\\]\\[]*[\"])\", [&](const string & s) { yysval = s; return NLD;}}, {\"[[:space:]]+\", [&](const string& match) { for (char c : match) { if (c == '\\n') { ++line_count; } } return -1; }}, // (\\s, \\t et \\n) {\".\", [&](const string& s) { return (int)s[0]; }} }); } string Scanner::getTokenName(int tokenId) { static const std::unordered_map<int, std::string> tokenNames = { {257, \"TEST_NAME\"}, {258, \"CLICK\"}, {259, \"VISIT\"}, {260, \"BUTTON\"}, {261, \"LINK\"}, {262, \"TEXT\"}, {263, \"IMAGE\"}, {264, \"DISPLAYED\"}, {265, \"HIDDEN\"}, {266, \"CHECK_IF\"}, {267, \"WITH_DESC\"}, {268, \"HOVER_OVER\"}, {269, \"NLD\"}, {270, \"URL\"}, {271, \"ON\"}, {272, \"TYPE\"}, {273, \"CONTENT\"}, {274, \"LEFT_BRACE\"}, {275, \"RIGHT_BRACE\"}, {276, \"INPUT\"} }; auto it = tokenNames.find(tokenId); return it != tokenNames.end() ? it->second : \"UNKNOWN\"; } int Scanner::line_number() const { return line_count; } int Scanner::yylex() { smatch m; while (true) { if (yyinput.length() == position) return 0; for (auto& rule : rules) { if (regex_search(yyinput.cbegin() + position, yyinput.cend(), m, regex(rule.regex), regex_constants::match_continuous)) { yytext = m.str(); position += m.length(); token = rule.lambda(yytext); if (token != -1) return token; else break; } } } }","title":"File scanner.cpp"},{"location":"compiler/scanner_8cpp_source/#file-scannercpp","text":"File List > src > scanner.cpp Go to the documentation of this file #include \"scanner.h\" string yysval; Scanner::Scanner(string&& content) : yyinput { content }, position { 0 }, token { 0ll } { if(content.empty()) return; rules = vector<lex_rule>({ {\"click\", [&](const string & s) { return CLICK;}}, {\"visit\", [&](const string & s) { return VISIT;}}, {\"button\", [&](const string & s) { yysval = s; return BUTTON;}}, {\"link\", [&](const string & s) { yysval = s; return LINK;}}, {\"text\", [&](const string & s) { yysval = s; return TEXT;}}, {\"input\", [&](const string & s) { yysval = s; return INPUT;}}, {\"image\", [&](const string & s) { yysval = s; return IMAGE;}}, {\"is displayed\", [&](const string & s) { return DISPLAYED;}}, {\"is hidden\", [&](const string & s) { return HIDDEN;}}, {\"check if\", [&](const string & s) { return CHECK_IF;}}, {\"with description\", [&](const string & s) { return WITH_DESC;}}, {\"hover over\", [&](const string & s) { return HOVER_OVER;}}, {\"on\", [&](const string & s) { return ON;}}, {\"type\", [&](const string & s) { return TYPE;}}, {\"[{]\", [&](const string & s) { return LEFT_BRACE;}}, {\"[}]\", [&](const string & s) { return RIGHT_BRACE;}}, {\"[\\\"]https://[a-zA-Z0-9./]*[\\\"]\", [&](const string & s) { yysval = s; return URL;}}, {\"[a-zA-Z][a-zA-Z0-9]*\", [&](const string & s) { yysval = s; return TEST_NAME;}}, {R\"([\"][a-zA-Z0-9 /@='\\]\\[]*[\"])\", [&](const string & s) { yysval = s; return NLD;}}, {\"[[:space:]]+\", [&](const string& match) { for (char c : match) { if (c == '\\n') { ++line_count; } } return -1; }}, // (\\s, \\t et \\n) {\".\", [&](const string& s) { return (int)s[0]; }} }); } string Scanner::getTokenName(int tokenId) { static const std::unordered_map<int, std::string> tokenNames = { {257, \"TEST_NAME\"}, {258, \"CLICK\"}, {259, \"VISIT\"}, {260, \"BUTTON\"}, {261, \"LINK\"}, {262, \"TEXT\"}, {263, \"IMAGE\"}, {264, \"DISPLAYED\"}, {265, \"HIDDEN\"}, {266, \"CHECK_IF\"}, {267, \"WITH_DESC\"}, {268, \"HOVER_OVER\"}, {269, \"NLD\"}, {270, \"URL\"}, {271, \"ON\"}, {272, \"TYPE\"}, {273, \"CONTENT\"}, {274, \"LEFT_BRACE\"}, {275, \"RIGHT_BRACE\"}, {276, \"INPUT\"} }; auto it = tokenNames.find(tokenId); return it != tokenNames.end() ? it->second : \"UNKNOWN\"; } int Scanner::line_number() const { return line_count; } int Scanner::yylex() { smatch m; while (true) { if (yyinput.length() == position) return 0; for (auto& rule : rules) { if (regex_search(yyinput.cbegin() + position, yyinput.cend(), m, regex(rule.regex), regex_constants::match_continuous)) { yytext = m.str(); position += m.length(); token = rule.lambda(yytext); if (token != -1) return token; else break; } } } }","title":"File scanner.cpp"},{"location":"compiler/scanner_8h/","text":"File scanner.h FileList > src > scanner.h Go to the source code of this file #include <string> #include <map> #include <functional> #include <iostream> #include <fstream> #include <regex> #include <vector> Classes Type Name class Scanner struct lex_rule Public Types Type Name enum Tokens Public Attributes Type Name string yysval Public Types Documentation enum Tokens enum Tokens { TEST_NAME = 257, CLICK, VISIT, BUTTON, LINK, TEXT, IMAGE, DISPLAYED, HIDDEN, CHECK_IF, WITH_DESC, HOVER_OVER, NLD, URL, ON, TYPE, CONTENT, LEFT_BRACE, RIGHT_BRACE, INPUT }; Public Attributes Documentation variable yysval string yysval; The documentation for this class was generated from the following file src/scanner.h","title":"Scanner"},{"location":"compiler/scanner_8h/#file-scannerh","text":"FileList > src > scanner.h Go to the source code of this file #include <string> #include <map> #include <functional> #include <iostream> #include <fstream> #include <regex> #include <vector>","title":"File scanner.h"},{"location":"compiler/scanner_8h/#classes","text":"Type Name class Scanner struct lex_rule","title":"Classes"},{"location":"compiler/scanner_8h/#public-types","text":"Type Name enum Tokens","title":"Public Types"},{"location":"compiler/scanner_8h/#public-attributes","text":"Type Name string yysval","title":"Public Attributes"},{"location":"compiler/scanner_8h/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"compiler/scanner_8h/#enum-tokens","text":"enum Tokens { TEST_NAME = 257, CLICK, VISIT, BUTTON, LINK, TEXT, IMAGE, DISPLAYED, HIDDEN, CHECK_IF, WITH_DESC, HOVER_OVER, NLD, URL, ON, TYPE, CONTENT, LEFT_BRACE, RIGHT_BRACE, INPUT };","title":"enum Tokens"},{"location":"compiler/scanner_8h/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"compiler/scanner_8h/#variable-yysval","text":"string yysval; The documentation for this class was generated from the following file src/scanner.h","title":"variable yysval"},{"location":"compiler/scanner_8h_source/","text":"File scanner.h File List > src > scanner.h Go to the documentation of this file #ifndef RESTRICTED_NL_SCANNER_H #define RESTRICTED_NL_SCANNER_H #include <string> #include <map> #include <functional> #include <iostream> #include <fstream> #include <regex> #include <vector> using namespace std; enum Tokens { TEST_NAME = 257, CLICK, VISIT, BUTTON, LINK, TEXT, IMAGE, DISPLAYED, HIDDEN, CHECK_IF, WITH_DESC, HOVER_OVER, NLD, URL, ON, TYPE, CONTENT, LEFT_BRACE, RIGHT_BRACE, INPUT }; extern string yysval; struct lex_rule { string regex; function<int(const string&)> lambda; }; class Scanner { private: int line_count = 1; string yytext; string yyinput; int token; long long position = 0; vector<lex_rule> rules; public: explicit Scanner(string&& content); static string getTokenName(int tokenId); int line_number() const; int yylex(); }; #endif //RESTRICTED_NL_SCANNER_H","title":"File scanner.h"},{"location":"compiler/scanner_8h_source/#file-scannerh","text":"File List > src > scanner.h Go to the documentation of this file #ifndef RESTRICTED_NL_SCANNER_H #define RESTRICTED_NL_SCANNER_H #include <string> #include <map> #include <functional> #include <iostream> #include <fstream> #include <regex> #include <vector> using namespace std; enum Tokens { TEST_NAME = 257, CLICK, VISIT, BUTTON, LINK, TEXT, IMAGE, DISPLAYED, HIDDEN, CHECK_IF, WITH_DESC, HOVER_OVER, NLD, URL, ON, TYPE, CONTENT, LEFT_BRACE, RIGHT_BRACE, INPUT }; extern string yysval; struct lex_rule { string regex; function<int(const string&)> lambda; }; class Scanner { private: int line_count = 1; string yytext; string yyinput; int token; long long position = 0; vector<lex_rule> rules; public: explicit Scanner(string&& content); static string getTokenName(int tokenId); int line_number() const; int yylex(); }; #endif //RESTRICTED_NL_SCANNER_H","title":"File scanner.h"},{"location":"compiler/dir_203e5988f1ed315d29383d699972de6f/","text":"Dir src/ast FileList > ast Files Type Name file AST.cpp file AST.h file JsonASTVisitor.cpp file JsonASTVisitor.h file SeleniumASTVisitor.cpp file SeleniumASTVisitor.h The documentation for this class was generated from the following file src/ast/","title":"Dir src/ast"},{"location":"compiler/dir_203e5988f1ed315d29383d699972de6f/#dir-srcast","text":"FileList > ast","title":"Dir src/ast"},{"location":"compiler/dir_203e5988f1ed315d29383d699972de6f/#files","text":"Type Name file AST.cpp file AST.h file JsonASTVisitor.cpp file JsonASTVisitor.h file SeleniumASTVisitor.cpp file SeleniumASTVisitor.h The documentation for this class was generated from the following file src/ast/","title":"Files"},{"location":"compiler/AST_8cpp/","text":"File AST.cpp FileList > ast > AST.cpp Go to the source code of this file #include \"AST.h\" The documentation for this class was generated from the following file src/ast/AST.cpp","title":"File AST.cpp"},{"location":"compiler/AST_8cpp/#file-astcpp","text":"FileList > ast > AST.cpp Go to the source code of this file #include \"AST.h\" The documentation for this class was generated from the following file src/ast/AST.cpp","title":"File AST.cpp"},{"location":"compiler/AST_8cpp_source/","text":"File AST.cpp File List > ast > AST.cpp Go to the documentation of this file // // Created by Ghady Youssef on 24/12/2024. // #include \"AST.h\" ClickNode::ClickNode(string &&element_type, string &&description) : element_type(std::move(element_type)), description(std::move(description)), ActionNode() {} TypeNode::TypeNode(string &&content, string &&element_type, string &&description) : content(std::move(content)), element_type(std::move(element_type)), description(std::move(description)) {} VisitNode::VisitNode(string &&url) : url(std::move(url)), ActionNode() {} CheckNode::CheckNode(string &&element_type, string &&description, bool state) : element_type(std::move(element_type)), description(std::move(description)), state(state), ActionNode() {} TestNode::TestNode(string&& testName, vector<ActionNode *> actions) : testName(std::move(testName)), actions(std::move(actions)) {} AST::AST() : tests(vector<TestNode>()) {} AST::AST(vector<TestNode> tests) : tests(std::move(tests)) {} string ClickNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string TypeNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string CheckNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string VisitNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string AST::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string TestNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string TypeNode::get_element_type() const { return element_type; } string TypeNode::get_description() const { return description; } string TypeNode::get_content() const { return content; } string CheckNode::get_element_type() const { return element_type; } string CheckNode::get_description() const { return description; } bool CheckNode::get_state() const { return state; } string ClickNode::get_element_type() const { return element_type; } string ClickNode::get_description() const { return description; }","title":"File AST.cpp"},{"location":"compiler/AST_8cpp_source/#file-astcpp","text":"File List > ast > AST.cpp Go to the documentation of this file // // Created by Ghady Youssef on 24/12/2024. // #include \"AST.h\" ClickNode::ClickNode(string &&element_type, string &&description) : element_type(std::move(element_type)), description(std::move(description)), ActionNode() {} TypeNode::TypeNode(string &&content, string &&element_type, string &&description) : content(std::move(content)), element_type(std::move(element_type)), description(std::move(description)) {} VisitNode::VisitNode(string &&url) : url(std::move(url)), ActionNode() {} CheckNode::CheckNode(string &&element_type, string &&description, bool state) : element_type(std::move(element_type)), description(std::move(description)), state(state), ActionNode() {} TestNode::TestNode(string&& testName, vector<ActionNode *> actions) : testName(std::move(testName)), actions(std::move(actions)) {} AST::AST() : tests(vector<TestNode>()) {} AST::AST(vector<TestNode> tests) : tests(std::move(tests)) {} string ClickNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string TypeNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string CheckNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string VisitNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string AST::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string TestNode::accept(ASTVisitor &visitor) const { return visitor.visit(*this); } string TypeNode::get_element_type() const { return element_type; } string TypeNode::get_description() const { return description; } string TypeNode::get_content() const { return content; } string CheckNode::get_element_type() const { return element_type; } string CheckNode::get_description() const { return description; } bool CheckNode::get_state() const { return state; } string ClickNode::get_element_type() const { return element_type; } string ClickNode::get_description() const { return description; }","title":"File AST.cpp"},{"location":"compiler/AST_8h/","text":"File AST.h FileList > ast > AST.h Go to the source code of this file #include <utility> #include <vector> #include <string> #include <sstream> Namespaces Type Name namespace std Classes Type Name class AST class ASTVisitor class ActionNode class CheckNode class ClickNode class TestNode class TypeNode class VisitNode The documentation for this class was generated from the following file src/ast/AST.h","title":"AST"},{"location":"compiler/AST_8h/#file-asth","text":"FileList > ast > AST.h Go to the source code of this file #include <utility> #include <vector> #include <string> #include <sstream>","title":"File AST.h"},{"location":"compiler/AST_8h/#namespaces","text":"Type Name namespace std","title":"Namespaces"},{"location":"compiler/AST_8h/#classes","text":"Type Name class AST class ASTVisitor class ActionNode class CheckNode class ClickNode class TestNode class TypeNode class VisitNode The documentation for this class was generated from the following file src/ast/AST.h","title":"Classes"},{"location":"compiler/AST_8h_source/","text":"File AST.h File List > ast > AST.h Go to the documentation of this file #ifndef RESTRICTED_NL_AST_H #define RESTRICTED_NL_AST_H #include <utility> #include<vector> #include<string> #include<sstream> using namespace std; class ASTVisitor; class ActionNode { public: ActionNode() = default; virtual string accept(ASTVisitor& visitor) const = 0; }; class VisitNode : public ActionNode { private: string url; public: explicit VisitNode(string&& url); string accept(ASTVisitor& visitor) const override; string get_url() const { return url; } }; class ClickNode : public ActionNode { private: string element_type; string description; public: explicit ClickNode(string&& element_type, string&& description); string accept(ASTVisitor& visitor) const override; string get_element_type() const; string get_description() const; }; class TypeNode : public ActionNode { string content; string element_type; string description; public: explicit TypeNode(string&& content, string&& element_type, string&& description); string accept(ASTVisitor& visitor) const override; string get_content() const; string get_element_type() const; string get_description() const; }; class CheckNode : public ActionNode { private: string element_type; string description; bool state; public: explicit CheckNode(string&& element_type, string&& description, bool state); string accept(ASTVisitor& visitor) const override; string get_element_type() const; string get_description() const; bool get_state() const; }; class TestNode { public: string testName; vector<ActionNode*> actions; string accept(ASTVisitor& visitor) const; explicit TestNode(string&& testName, vector<ActionNode*> actions); }; class AST { public: vector<TestNode> tests; string accept(ASTVisitor& visitor) const; explicit AST(vector<TestNode> tests); explicit AST(); }; class ASTVisitor { public: virtual string visit(const VisitNode& node) = 0; virtual string visit(const ClickNode& node) = 0; virtual string visit(const TypeNode& node) = 0; virtual string visit(const CheckNode& node) = 0; virtual string visit(const TestNode& node) = 0; virtual string visit(const AST& tree) = 0; }; #endif //RESTRICTED_NL_AST_H","title":"File AST.h"},{"location":"compiler/AST_8h_source/#file-asth","text":"File List > ast > AST.h Go to the documentation of this file #ifndef RESTRICTED_NL_AST_H #define RESTRICTED_NL_AST_H #include <utility> #include<vector> #include<string> #include<sstream> using namespace std; class ASTVisitor; class ActionNode { public: ActionNode() = default; virtual string accept(ASTVisitor& visitor) const = 0; }; class VisitNode : public ActionNode { private: string url; public: explicit VisitNode(string&& url); string accept(ASTVisitor& visitor) const override; string get_url() const { return url; } }; class ClickNode : public ActionNode { private: string element_type; string description; public: explicit ClickNode(string&& element_type, string&& description); string accept(ASTVisitor& visitor) const override; string get_element_type() const; string get_description() const; }; class TypeNode : public ActionNode { string content; string element_type; string description; public: explicit TypeNode(string&& content, string&& element_type, string&& description); string accept(ASTVisitor& visitor) const override; string get_content() const; string get_element_type() const; string get_description() const; }; class CheckNode : public ActionNode { private: string element_type; string description; bool state; public: explicit CheckNode(string&& element_type, string&& description, bool state); string accept(ASTVisitor& visitor) const override; string get_element_type() const; string get_description() const; bool get_state() const; }; class TestNode { public: string testName; vector<ActionNode*> actions; string accept(ASTVisitor& visitor) const; explicit TestNode(string&& testName, vector<ActionNode*> actions); }; class AST { public: vector<TestNode> tests; string accept(ASTVisitor& visitor) const; explicit AST(vector<TestNode> tests); explicit AST(); }; class ASTVisitor { public: virtual string visit(const VisitNode& node) = 0; virtual string visit(const ClickNode& node) = 0; virtual string visit(const TypeNode& node) = 0; virtual string visit(const CheckNode& node) = 0; virtual string visit(const TestNode& node) = 0; virtual string visit(const AST& tree) = 0; }; #endif //RESTRICTED_NL_AST_H","title":"File AST.h"},{"location":"compiler/JsonASTVisitor_8cpp/","text":"File JsonASTVisitor.cpp FileList > ast > JsonASTVisitor.cpp Go to the source code of this file #include \"JsonASTVisitor.h\" #include <nlohmann/json.hpp> #include <sstream> Public Types Type Name typedef nlohmann::json json Public Types Documentation typedef json using json = nlohmann::json; The documentation for this class was generated from the following file src/ast/JsonASTVisitor.cpp","title":"File JsonASTVisitor.cpp"},{"location":"compiler/JsonASTVisitor_8cpp/#file-jsonastvisitorcpp","text":"FileList > ast > JsonASTVisitor.cpp Go to the source code of this file #include \"JsonASTVisitor.h\" #include <nlohmann/json.hpp> #include <sstream>","title":"File JsonASTVisitor.cpp"},{"location":"compiler/JsonASTVisitor_8cpp/#public-types","text":"Type Name typedef nlohmann::json json","title":"Public Types"},{"location":"compiler/JsonASTVisitor_8cpp/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"compiler/JsonASTVisitor_8cpp/#typedef-json","text":"using json = nlohmann::json; The documentation for this class was generated from the following file src/ast/JsonASTVisitor.cpp","title":"typedef json"},{"location":"compiler/JsonASTVisitor_8cpp_source/","text":"File JsonASTVisitor.cpp File List > ast > JsonASTVisitor.cpp Go to the documentation of this file // // Created by A-Karam on 1/21/2025. // #include \"JsonASTVisitor.h\" #include <nlohmann/json.hpp> #include <sstream> using json = nlohmann::json; string JsonASTVisitor::visit(const VisitNode &node) { json json_visit = { {\"action\", \"visit\"}, {\"url\", node.get_url()} }; return json_visit.dump(); } string JsonASTVisitor::visit(const ClickNode &node) { json json_click = { {\"action\", \"click\"}, {\"description\", node.get_description()}, {\"elementType\", node.get_element_type()} }; return json_click.dump(); } string JsonASTVisitor::visit(const TypeNode &node) { json json_type = { {\"action\", \"type\"}, {\"description\", node.get_description()}, {\"content\", node.get_content()}, {\"elementType\", node.get_element_type()} }; return json_type.dump(); } string JsonASTVisitor::visit(const CheckNode &node) { json json_check = { {\"action\", \"check\"}, {\"description\", node.get_description()}, {\"elementType\", node.get_element_type()}, {\"state\", node.get_state()} }; return json_check.dump(); } string JsonASTVisitor::visit(const TestNode &node) { vector<json> json_actions; for(auto& action : node.actions) { json_actions.push_back(json::parse(action->accept(*this))); } json json_test = { {\"testName\", node.testName}, {\"actions\", json_actions} }; return json_test.dump(); } string JsonASTVisitor::visit(const AST &tree) { vector<json> json_tests; for(auto& test : tree.tests) { json_tests.push_back(json::parse(test.accept(*this))); } json json_ast = { {\"tests\", json_tests} }; return json_ast.dump(); }","title":"File JsonASTVisitor.cpp"},{"location":"compiler/JsonASTVisitor_8cpp_source/#file-jsonastvisitorcpp","text":"File List > ast > JsonASTVisitor.cpp Go to the documentation of this file // // Created by A-Karam on 1/21/2025. // #include \"JsonASTVisitor.h\" #include <nlohmann/json.hpp> #include <sstream> using json = nlohmann::json; string JsonASTVisitor::visit(const VisitNode &node) { json json_visit = { {\"action\", \"visit\"}, {\"url\", node.get_url()} }; return json_visit.dump(); } string JsonASTVisitor::visit(const ClickNode &node) { json json_click = { {\"action\", \"click\"}, {\"description\", node.get_description()}, {\"elementType\", node.get_element_type()} }; return json_click.dump(); } string JsonASTVisitor::visit(const TypeNode &node) { json json_type = { {\"action\", \"type\"}, {\"description\", node.get_description()}, {\"content\", node.get_content()}, {\"elementType\", node.get_element_type()} }; return json_type.dump(); } string JsonASTVisitor::visit(const CheckNode &node) { json json_check = { {\"action\", \"check\"}, {\"description\", node.get_description()}, {\"elementType\", node.get_element_type()}, {\"state\", node.get_state()} }; return json_check.dump(); } string JsonASTVisitor::visit(const TestNode &node) { vector<json> json_actions; for(auto& action : node.actions) { json_actions.push_back(json::parse(action->accept(*this))); } json json_test = { {\"testName\", node.testName}, {\"actions\", json_actions} }; return json_test.dump(); } string JsonASTVisitor::visit(const AST &tree) { vector<json> json_tests; for(auto& test : tree.tests) { json_tests.push_back(json::parse(test.accept(*this))); } json json_ast = { {\"tests\", json_tests} }; return json_ast.dump(); }","title":"File JsonASTVisitor.cpp"},{"location":"compiler/JsonASTVisitor_8h/","text":"File JsonASTVisitor.h FileList > ast > JsonASTVisitor.h Go to the source code of this file #include \"AST.h\" Classes Type Name class JsonASTVisitor The documentation for this class was generated from the following file src/ast/JsonASTVisitor.h","title":"SeleniumASTVisitor"},{"location":"compiler/JsonASTVisitor_8h/#file-jsonastvisitorh","text":"FileList > ast > JsonASTVisitor.h Go to the source code of this file #include \"AST.h\"","title":"File JsonASTVisitor.h"},{"location":"compiler/JsonASTVisitor_8h/#classes","text":"Type Name class JsonASTVisitor The documentation for this class was generated from the following file src/ast/JsonASTVisitor.h","title":"Classes"},{"location":"compiler/JsonASTVisitor_8h_source/","text":"File JsonASTVisitor.h File List > ast > JsonASTVisitor.h Go to the documentation of this file // // Created by A-Karam on 1/21/2025. // #ifndef RESTRICTED_NL_JSONASTVISITOR_H #define RESTRICTED_NL_JSONASTVISITOR_H #include \"AST.h\" class JsonASTVisitor : public ASTVisitor { public: string visit(const VisitNode& node) override; string visit(const ClickNode& node) override; string visit(const TypeNode& node) override; string visit(const CheckNode& node) override; string visit(const TestNode& node) override; string visit(const AST& tree) override; }; #endif //RESTRICTED_NL_JSONASTVISITOR_H","title":"File JsonASTVisitor.h"},{"location":"compiler/JsonASTVisitor_8h_source/#file-jsonastvisitorh","text":"File List > ast > JsonASTVisitor.h Go to the documentation of this file // // Created by A-Karam on 1/21/2025. // #ifndef RESTRICTED_NL_JSONASTVISITOR_H #define RESTRICTED_NL_JSONASTVISITOR_H #include \"AST.h\" class JsonASTVisitor : public ASTVisitor { public: string visit(const VisitNode& node) override; string visit(const ClickNode& node) override; string visit(const TypeNode& node) override; string visit(const CheckNode& node) override; string visit(const TestNode& node) override; string visit(const AST& tree) override; }; #endif //RESTRICTED_NL_JSONASTVISITOR_H","title":"File JsonASTVisitor.h"},{"location":"compiler/SeleniumASTVisitor_8cpp/","text":"File SeleniumASTVisitor.cpp FileList > ast > SeleniumASTVisitor.cpp Go to the source code of this file #include \"SeleniumASTVisitor.h\" #include <sstream> The documentation for this class was generated from the following file src/ast/SeleniumASTVisitor.cpp","title":"File SeleniumASTVisitor.cpp"},{"location":"compiler/SeleniumASTVisitor_8cpp/#file-seleniumastvisitorcpp","text":"FileList > ast > SeleniumASTVisitor.cpp Go to the source code of this file #include \"SeleniumASTVisitor.h\" #include <sstream> The documentation for this class was generated from the following file src/ast/SeleniumASTVisitor.cpp","title":"File SeleniumASTVisitor.cpp"},{"location":"compiler/SeleniumASTVisitor_8cpp_source/","text":"File SeleniumASTVisitor.cpp File List > ast > SeleniumASTVisitor.cpp Go to the documentation of this file #include \"SeleniumASTVisitor.h\" #include <sstream> string SeleniumASTVisitor::visit(const VisitNode &node) { stringstream ss; ss << \"await driver.get(\" << node.get_url() << \");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const ClickNode &node) { stringstream ss; ss << \"await clickNode(driver, \" << node.get_description() << \", \\\"\" << node.get_element_type() << \"\\\");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const TypeNode &node) { stringstream ss; ss << \"await typeNode(driver, \" << node.get_description() << \", \" << node.get_content() << \", \\\"\" << node.get_element_type() << \"\\\");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const CheckNode &node) { stringstream ss; string state = (node.get_state() ? \"true\" : \"false\"); ss << \"assert.equal(await checkNode(driver, \\\"\" << node.get_element_type() << \"\\\", \" << node.get_description() << \", \" << state << \", title), \" << state << \");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const TestNode &node) { stringstream ss; ss << \"it('\" << node.testName << \"', async function () {\" << std::endl << \"const title = '\" << node.testName << \"';\" << std::endl; for(auto& action : node.actions) { ss << action->accept(*this); } ss << \"});\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const AST &tree) { stringstream ss; ss << init_hooks(); if(!keep_xpath) { ss << get_coordinates() << element_from_point(); } if(keep_xpath) { // with xpath ss << generate_xpath_helper(); } else { // with NL description ss << generate_seeclick_helper(); } ss << generate_init(); for(auto& test : tree.tests) { ss << test.accept(*this); } ss << end(); return ss.str(); } string SeleniumASTVisitor::generate_xpath_helper() { stringstream ss; ss << R\"( async function clickNode(driver, description, element_type) { const element = await driver.findElement(By.xpath(description)); await element.click(); })\" << std::endl; ss << R\"( async function typeNode(driver, description, content, element_type) { const element = await driver.findElement(By.xpath(description)); await element.sendKeys(content); })\" << std::endl; ss << R\"( async function checkNode(driver, element_type, description, state, test) { const element = await driver.findElement(By.xpath(description)); let isDisplayed = await element.isDisplayed(); await afterEachAssertHook(`${element_type} with description \"${description}\" should be ${state ? 'displayed' : 'hidden'}`, isDisplayed == state, test); return isDisplayed; })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::generate_seeclick_helper() { stringstream ss; ss << R\"( async function clickNode(driver, description, element_type) { const [x, y] = await getCoordinates(driver, description, element_type); const actions = driver.actions({ async: true }); await actions.move({ x, y }).click().perform(); })\" << std::endl; ss << R\"( async function typeNode(driver, description, content, element_type) { const [x, y] = await getCoordinates(driver, description, element_type); const actions = driver.actions({ async: true }); await actions.move({ x, y }).click().sendKeys(content).perform(); })\" << std::endl; ss << R\"( async function checkNode(driver, element_type, description, state, test) { const [x, y] = await getCoordinates(driver, description, element_type); let element = await elementFromPoint(driver, x, y); let isDisplayed = await element.isDisplayed(); await afterEachAssertHook(`${element_type} with description \"${description}\" should be ${state ? 'displayed' : 'hidden'}`, isDisplayed == state, test); return isDisplayed; })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::generate_init() { stringstream ss; ss << R\"(describe(\"Script\", function () { let driver; this.timeout(0); before(beforeHook); beforeEach(beforeEachHook); after(afterHook); afterEach(afterEachHook); before(async function () { driver = await new Builder().forBrowser(Browser.CHROME) .setChromeOptions(new chrome.Options().addArguments(\"--window-size=1920,1080\")) .build(); await driver .manage() .setTimeouts({ implicit: 2147483647, pageLoad: 2147483647 }); }); after(async () => { await driver.quit(); });)\" << std::endl; return ss.str(); } string SeleniumASTVisitor::element_from_point() { stringstream ss; ss << R\"(async function elementFromPoint(driver, x, y) { return await driver.executeScript( \"return document.elementFromPoint(arguments[0], arguments[1]);\", x, y ); })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::get_coordinates() { stringstream ss; ss << R\"(async function getCoordinates(driver, description, element_type) { try { const res = await fetch(getServerURL(), { method: \"POST\", headers: { \"Content-Type\": \"application/json\", \"Authorization\": `Bearer ${getToken()}` }, body: JSON.stringify({ image: await driver.takeScreenshot(), description: description, element_type: element_type }), }); const data = await res.json(); if (res.ok) { return data; } else { throw new Error(\"Error in fetching coordinates\"); } } catch (error) { throw new Error(\"Error in fetching coordinates\"); } })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::init_hooks() { stringstream ss; ss << \"const { Builder, Browser, By } = require('selenium-webdriver');\" << std::endl; ss << \"const assert = require('assert');\" << std::endl; ss << \"const chrome = require(\\\"selenium-webdriver/chrome\\\");\" << std::endl; ss << \"function beforeHook() {}\" << std::endl; ss << \"function beforeEachHook() {}\" << std::endl; ss << \"function afterHook() {}\" << std::endl; ss << \"function afterEachHook() {}\" << std::endl; ss << \"function afterEachAssertHook() {}\" << std::endl; ss << \"function getToken() {}\" << std::endl; ss << \"function getServerURL() {}\" << std::endl; return ss.str(); } string SeleniumASTVisitor::end() { stringstream ss; ss << \"});\\n\"; return ss.str(); }","title":"File SeleniumASTVisitor.cpp"},{"location":"compiler/SeleniumASTVisitor_8cpp_source/#file-seleniumastvisitorcpp","text":"File List > ast > SeleniumASTVisitor.cpp Go to the documentation of this file #include \"SeleniumASTVisitor.h\" #include <sstream> string SeleniumASTVisitor::visit(const VisitNode &node) { stringstream ss; ss << \"await driver.get(\" << node.get_url() << \");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const ClickNode &node) { stringstream ss; ss << \"await clickNode(driver, \" << node.get_description() << \", \\\"\" << node.get_element_type() << \"\\\");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const TypeNode &node) { stringstream ss; ss << \"await typeNode(driver, \" << node.get_description() << \", \" << node.get_content() << \", \\\"\" << node.get_element_type() << \"\\\");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const CheckNode &node) { stringstream ss; string state = (node.get_state() ? \"true\" : \"false\"); ss << \"assert.equal(await checkNode(driver, \\\"\" << node.get_element_type() << \"\\\", \" << node.get_description() << \", \" << state << \", title), \" << state << \");\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const TestNode &node) { stringstream ss; ss << \"it('\" << node.testName << \"', async function () {\" << std::endl << \"const title = '\" << node.testName << \"';\" << std::endl; for(auto& action : node.actions) { ss << action->accept(*this); } ss << \"});\" << std::endl; return ss.str(); } string SeleniumASTVisitor::visit(const AST &tree) { stringstream ss; ss << init_hooks(); if(!keep_xpath) { ss << get_coordinates() << element_from_point(); } if(keep_xpath) { // with xpath ss << generate_xpath_helper(); } else { // with NL description ss << generate_seeclick_helper(); } ss << generate_init(); for(auto& test : tree.tests) { ss << test.accept(*this); } ss << end(); return ss.str(); } string SeleniumASTVisitor::generate_xpath_helper() { stringstream ss; ss << R\"( async function clickNode(driver, description, element_type) { const element = await driver.findElement(By.xpath(description)); await element.click(); })\" << std::endl; ss << R\"( async function typeNode(driver, description, content, element_type) { const element = await driver.findElement(By.xpath(description)); await element.sendKeys(content); })\" << std::endl; ss << R\"( async function checkNode(driver, element_type, description, state, test) { const element = await driver.findElement(By.xpath(description)); let isDisplayed = await element.isDisplayed(); await afterEachAssertHook(`${element_type} with description \"${description}\" should be ${state ? 'displayed' : 'hidden'}`, isDisplayed == state, test); return isDisplayed; })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::generate_seeclick_helper() { stringstream ss; ss << R\"( async function clickNode(driver, description, element_type) { const [x, y] = await getCoordinates(driver, description, element_type); const actions = driver.actions({ async: true }); await actions.move({ x, y }).click().perform(); })\" << std::endl; ss << R\"( async function typeNode(driver, description, content, element_type) { const [x, y] = await getCoordinates(driver, description, element_type); const actions = driver.actions({ async: true }); await actions.move({ x, y }).click().sendKeys(content).perform(); })\" << std::endl; ss << R\"( async function checkNode(driver, element_type, description, state, test) { const [x, y] = await getCoordinates(driver, description, element_type); let element = await elementFromPoint(driver, x, y); let isDisplayed = await element.isDisplayed(); await afterEachAssertHook(`${element_type} with description \"${description}\" should be ${state ? 'displayed' : 'hidden'}`, isDisplayed == state, test); return isDisplayed; })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::generate_init() { stringstream ss; ss << R\"(describe(\"Script\", function () { let driver; this.timeout(0); before(beforeHook); beforeEach(beforeEachHook); after(afterHook); afterEach(afterEachHook); before(async function () { driver = await new Builder().forBrowser(Browser.CHROME) .setChromeOptions(new chrome.Options().addArguments(\"--window-size=1920,1080\")) .build(); await driver .manage() .setTimeouts({ implicit: 2147483647, pageLoad: 2147483647 }); }); after(async () => { await driver.quit(); });)\" << std::endl; return ss.str(); } string SeleniumASTVisitor::element_from_point() { stringstream ss; ss << R\"(async function elementFromPoint(driver, x, y) { return await driver.executeScript( \"return document.elementFromPoint(arguments[0], arguments[1]);\", x, y ); })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::get_coordinates() { stringstream ss; ss << R\"(async function getCoordinates(driver, description, element_type) { try { const res = await fetch(getServerURL(), { method: \"POST\", headers: { \"Content-Type\": \"application/json\", \"Authorization\": `Bearer ${getToken()}` }, body: JSON.stringify({ image: await driver.takeScreenshot(), description: description, element_type: element_type }), }); const data = await res.json(); if (res.ok) { return data; } else { throw new Error(\"Error in fetching coordinates\"); } } catch (error) { throw new Error(\"Error in fetching coordinates\"); } })\" << std::endl; return ss.str(); } string SeleniumASTVisitor::init_hooks() { stringstream ss; ss << \"const { Builder, Browser, By } = require('selenium-webdriver');\" << std::endl; ss << \"const assert = require('assert');\" << std::endl; ss << \"const chrome = require(\\\"selenium-webdriver/chrome\\\");\" << std::endl; ss << \"function beforeHook() {}\" << std::endl; ss << \"function beforeEachHook() {}\" << std::endl; ss << \"function afterHook() {}\" << std::endl; ss << \"function afterEachHook() {}\" << std::endl; ss << \"function afterEachAssertHook() {}\" << std::endl; ss << \"function getToken() {}\" << std::endl; ss << \"function getServerURL() {}\" << std::endl; return ss.str(); } string SeleniumASTVisitor::end() { stringstream ss; ss << \"});\\n\"; return ss.str(); }","title":"File SeleniumASTVisitor.cpp"},{"location":"compiler/SeleniumASTVisitor_8h/","text":"File SeleniumASTVisitor.h FileList > ast > SeleniumASTVisitor.h Go to the source code of this file #include \"AST.h\" Classes Type Name class SeleniumASTVisitor The documentation for this class was generated from the following file src/ast/SeleniumASTVisitor.h","title":"JsonASTVisitor"},{"location":"compiler/SeleniumASTVisitor_8h/#file-seleniumastvisitorh","text":"FileList > ast > SeleniumASTVisitor.h Go to the source code of this file #include \"AST.h\"","title":"File SeleniumASTVisitor.h"},{"location":"compiler/SeleniumASTVisitor_8h/#classes","text":"Type Name class SeleniumASTVisitor The documentation for this class was generated from the following file src/ast/SeleniumASTVisitor.h","title":"Classes"},{"location":"compiler/SeleniumASTVisitor_8h_source/","text":"File SeleniumASTVisitor.h File List > ast > SeleniumASTVisitor.h Go to the documentation of this file // // Created by King Antoine on 24/12/2024. // #ifndef RESTRICTED_NL_SELENIUMASTVISITOR_H #define RESTRICTED_NL_SELENIUMASTVISITOR_H #include \"AST.h\" class SeleniumASTVisitor : public ASTVisitor { private: bool keep_xpath; static string generate_init(); static string generate_xpath_helper(); static string generate_seeclick_helper(); static string init_hooks(); static string get_coordinates(); static string element_from_point(); static string end(); public: explicit SeleniumASTVisitor(bool keep_xpath) : keep_xpath(keep_xpath) {} string visit(const VisitNode& node) override; string visit(const ClickNode& node) override; string visit(const TypeNode& node) override; string visit(const CheckNode& node) override; string visit(const TestNode& node) override; string visit(const AST& tree) override; }; #endif //RESTRICTED_NL_SELENIUMASTVISITOR_H","title":"File SeleniumASTVisitor.h"},{"location":"compiler/SeleniumASTVisitor_8h_source/#file-seleniumastvisitorh","text":"File List > ast > SeleniumASTVisitor.h Go to the documentation of this file // // Created by King Antoine on 24/12/2024. // #ifndef RESTRICTED_NL_SELENIUMASTVISITOR_H #define RESTRICTED_NL_SELENIUMASTVISITOR_H #include \"AST.h\" class SeleniumASTVisitor : public ASTVisitor { private: bool keep_xpath; static string generate_init(); static string generate_xpath_helper(); static string generate_seeclick_helper(); static string init_hooks(); static string get_coordinates(); static string element_from_point(); static string end(); public: explicit SeleniumASTVisitor(bool keep_xpath) : keep_xpath(keep_xpath) {} string visit(const VisitNode& node) override; string visit(const ClickNode& node) override; string visit(const TypeNode& node) override; string visit(const CheckNode& node) override; string visit(const TestNode& node) override; string visit(const AST& tree) override; }; #endif //RESTRICTED_NL_SELENIUMASTVISITOR_H","title":"File SeleniumASTVisitor.h"},{"location":"compiler/namespaces/","text":"Namespace List Here is a list of all namespaces with brief descriptions: namespace std","title":"Namespace List"},{"location":"compiler/namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace std","title":"Namespace List"},{"location":"compiler/classes/","text":"Class Index a ActionNode AST ASTVisitor c CheckNode ClickNode j JsonASTVisitor l lex_rule p parser s Scanner SeleniumASTVisitor t TestNode TypeNode v VisitNode","title":"Class Index"},{"location":"compiler/classes/#class-index","text":"","title":"Class Index"},{"location":"compiler/classes/#a","text":"ActionNode AST ASTVisitor","title":"a"},{"location":"compiler/classes/#c","text":"CheckNode ClickNode","title":"c"},{"location":"compiler/classes/#j","text":"JsonASTVisitor","title":"j"},{"location":"compiler/classes/#l","text":"lex_rule","title":"l"},{"location":"compiler/classes/#p","text":"parser","title":"p"},{"location":"compiler/classes/#s","text":"Scanner SeleniumASTVisitor","title":"s"},{"location":"compiler/classes/#t","text":"TestNode TypeNode","title":"t"},{"location":"compiler/classes/#v","text":"VisitNode","title":"v"},{"location":"compiler/hierarchy/","text":"Class Hierarchy This inheritance list is sorted roughly, but not completely, alphabetically: class AST class ASTVisitor class JsonASTVisitor class SeleniumASTVisitor class ActionNode class CheckNode class ClickNode class TypeNode class VisitNode class Scanner class TestNode class parser struct lex_rule","title":"Class Hierarchy"},{"location":"compiler/hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class AST class ASTVisitor class JsonASTVisitor class SeleniumASTVisitor class ActionNode class CheckNode class ClickNode class TypeNode class VisitNode class Scanner class TestNode class parser struct lex_rule","title":"Class Hierarchy"},{"location":"compiler/modules/","text":"Modules No modules found.","title":"Modules"},{"location":"compiler/modules/#modules","text":"No modules found.","title":"Modules"},{"location":"compiler/pages/","text":"Related Pages Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"compiler/pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"compiler/class_members/","text":"Class Members a AST ( AST ) accept ( AST , ActionNode , CheckNode , ClickNode , TestNode , TypeNode , VisitNode ) ActionNode ( ActionNode ) actions ( TestNode ) action ( parser ) b body ( parser ) c CheckNode ( CheckNode ) ClickNode ( ClickNode ) content ( TypeNode ) check ( parser ) click ( parser ) d description ( CheckNode , ClickNode , TypeNode ) e element_type ( CheckNode , ClickNode , TypeNode ) element_from_point ( SeleniumASTVisitor ) end ( SeleniumASTVisitor ) elem_type ( parser ) errors ( parser ) g get_description ( CheckNode , ClickNode , TypeNode ) get_element_type ( CheckNode , ClickNode , TypeNode ) get_state ( CheckNode ) getTokenName ( Scanner ) generate_init ( SeleniumASTVisitor ) generate_seeclick_helper ( SeleniumASTVisitor ) generate_xpath_helper ( SeleniumASTVisitor ) get_coordinates ( SeleniumASTVisitor ) get_content ( TypeNode ) get_url ( VisitNode ) h hover ( parser ) i init_hooks ( SeleniumASTVisitor ) k keep_xpath ( SeleniumASTVisitor ) l line_count ( Scanner ) line_number ( Scanner ) lambda ( lex_rule ) p position ( Scanner ) parse ( parser ) parser ( parser ) program ( parser ) r rules ( Scanner ) regex ( lex_rule ) recoverFromError ( parser ) reportError ( parser ) s state ( CheckNode , parser ) Scanner ( Scanner ) SeleniumASTVisitor ( SeleniumASTVisitor ) scanner ( parser ) t tests ( AST ) token ( Scanner , parser ) TestNode ( TestNode ) testName ( TestNode ) TypeNode ( TypeNode ) test ( parser ) tree ( parser ) type ( parser ) u url ( VisitNode ) v visit ( ASTVisitor , JsonASTVisitor , SeleniumASTVisitor , parser ) VisitNode ( VisitNode ) y yyinput ( Scanner ) yylex ( Scanner ) yytext ( Scanner )","title":"Class Members"},{"location":"compiler/class_members/#class-members","text":"","title":"Class Members"},{"location":"compiler/class_members/#a","text":"AST ( AST ) accept ( AST , ActionNode , CheckNode , ClickNode , TestNode , TypeNode , VisitNode ) ActionNode ( ActionNode ) actions ( TestNode ) action ( parser )","title":"a"},{"location":"compiler/class_members/#b","text":"body ( parser )","title":"b"},{"location":"compiler/class_members/#c","text":"CheckNode ( CheckNode ) ClickNode ( ClickNode ) content ( TypeNode ) check ( parser ) click ( parser )","title":"c"},{"location":"compiler/class_members/#d","text":"description ( CheckNode , ClickNode , TypeNode )","title":"d"},{"location":"compiler/class_members/#e","text":"element_type ( CheckNode , ClickNode , TypeNode ) element_from_point ( SeleniumASTVisitor ) end ( SeleniumASTVisitor ) elem_type ( parser ) errors ( parser )","title":"e"},{"location":"compiler/class_members/#g","text":"get_description ( CheckNode , ClickNode , TypeNode ) get_element_type ( CheckNode , ClickNode , TypeNode ) get_state ( CheckNode ) getTokenName ( Scanner ) generate_init ( SeleniumASTVisitor ) generate_seeclick_helper ( SeleniumASTVisitor ) generate_xpath_helper ( SeleniumASTVisitor ) get_coordinates ( SeleniumASTVisitor ) get_content ( TypeNode ) get_url ( VisitNode )","title":"g"},{"location":"compiler/class_members/#h","text":"hover ( parser )","title":"h"},{"location":"compiler/class_members/#i","text":"init_hooks ( SeleniumASTVisitor )","title":"i"},{"location":"compiler/class_members/#k","text":"keep_xpath ( SeleniumASTVisitor )","title":"k"},{"location":"compiler/class_members/#l","text":"line_count ( Scanner ) line_number ( Scanner ) lambda ( lex_rule )","title":"l"},{"location":"compiler/class_members/#p","text":"position ( Scanner ) parse ( parser ) parser ( parser ) program ( parser )","title":"p"},{"location":"compiler/class_members/#r","text":"rules ( Scanner ) regex ( lex_rule ) recoverFromError ( parser ) reportError ( parser )","title":"r"},{"location":"compiler/class_members/#s","text":"state ( CheckNode , parser ) Scanner ( Scanner ) SeleniumASTVisitor ( SeleniumASTVisitor ) scanner ( parser )","title":"s"},{"location":"compiler/class_members/#t","text":"tests ( AST ) token ( Scanner , parser ) TestNode ( TestNode ) testName ( TestNode ) TypeNode ( TypeNode ) test ( parser ) tree ( parser ) type ( parser )","title":"t"},{"location":"compiler/class_members/#u","text":"url ( VisitNode )","title":"u"},{"location":"compiler/class_members/#v","text":"visit ( ASTVisitor , JsonASTVisitor , SeleniumASTVisitor , parser ) VisitNode ( VisitNode )","title":"v"},{"location":"compiler/class_members/#y","text":"yyinput ( Scanner ) yylex ( Scanner ) yytext ( Scanner )","title":"y"},{"location":"compiler/class_member_functions/","text":"Class Member Functions a AST ( AST ) accept ( AST , ActionNode , CheckNode , ClickNode , TestNode , TypeNode , VisitNode ) ActionNode ( ActionNode ) action ( parser ) b body ( parser ) c CheckNode ( CheckNode ) ClickNode ( ClickNode ) check ( parser ) click ( parser ) e element_from_point ( SeleniumASTVisitor ) end ( SeleniumASTVisitor ) elem_type ( parser ) g get_description ( CheckNode , ClickNode , TypeNode ) get_element_type ( CheckNode , ClickNode , TypeNode ) get_state ( CheckNode ) getTokenName ( Scanner ) generate_init ( SeleniumASTVisitor ) generate_seeclick_helper ( SeleniumASTVisitor ) generate_xpath_helper ( SeleniumASTVisitor ) get_coordinates ( SeleniumASTVisitor ) get_content ( TypeNode ) get_url ( VisitNode ) h hover ( parser ) i init_hooks ( SeleniumASTVisitor ) l line_number ( Scanner ) p parse ( parser ) parser ( parser ) program ( parser ) r recoverFromError ( parser ) reportError ( parser ) s Scanner ( Scanner ) SeleniumASTVisitor ( SeleniumASTVisitor ) state ( parser ) t TestNode ( TestNode ) TypeNode ( TypeNode ) test ( parser ) type ( parser ) v visit ( ASTVisitor , JsonASTVisitor , SeleniumASTVisitor , parser ) VisitNode ( VisitNode ) y yylex ( Scanner )","title":"Class Member Functions"},{"location":"compiler/class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"compiler/class_member_functions/#a","text":"AST ( AST ) accept ( AST , ActionNode , CheckNode , ClickNode , TestNode , TypeNode , VisitNode ) ActionNode ( ActionNode ) action ( parser )","title":"a"},{"location":"compiler/class_member_functions/#b","text":"body ( parser )","title":"b"},{"location":"compiler/class_member_functions/#c","text":"CheckNode ( CheckNode ) ClickNode ( ClickNode ) check ( parser ) click ( parser )","title":"c"},{"location":"compiler/class_member_functions/#e","text":"element_from_point ( SeleniumASTVisitor ) end ( SeleniumASTVisitor ) elem_type ( parser )","title":"e"},{"location":"compiler/class_member_functions/#g","text":"get_description ( CheckNode , ClickNode , TypeNode ) get_element_type ( CheckNode , ClickNode , TypeNode ) get_state ( CheckNode ) getTokenName ( Scanner ) generate_init ( SeleniumASTVisitor ) generate_seeclick_helper ( SeleniumASTVisitor ) generate_xpath_helper ( SeleniumASTVisitor ) get_coordinates ( SeleniumASTVisitor ) get_content ( TypeNode ) get_url ( VisitNode )","title":"g"},{"location":"compiler/class_member_functions/#h","text":"hover ( parser )","title":"h"},{"location":"compiler/class_member_functions/#i","text":"init_hooks ( SeleniumASTVisitor )","title":"i"},{"location":"compiler/class_member_functions/#l","text":"line_number ( Scanner )","title":"l"},{"location":"compiler/class_member_functions/#p","text":"parse ( parser ) parser ( parser ) program ( parser )","title":"p"},{"location":"compiler/class_member_functions/#r","text":"recoverFromError ( parser ) reportError ( parser )","title":"r"},{"location":"compiler/class_member_functions/#s","text":"Scanner ( Scanner ) SeleniumASTVisitor ( SeleniumASTVisitor ) state ( parser )","title":"s"},{"location":"compiler/class_member_functions/#t","text":"TestNode ( TestNode ) TypeNode ( TypeNode ) test ( parser ) type ( parser )","title":"t"},{"location":"compiler/class_member_functions/#v","text":"visit ( ASTVisitor , JsonASTVisitor , SeleniumASTVisitor , parser ) VisitNode ( VisitNode )","title":"v"},{"location":"compiler/class_member_functions/#y","text":"yylex ( Scanner )","title":"y"},{"location":"compiler/class_member_variables/","text":"Class Member Variables a actions ( TestNode ) c content ( TypeNode ) d description ( CheckNode , ClickNode , TypeNode ) e element_type ( CheckNode , ClickNode , TypeNode ) errors ( parser ) k keep_xpath ( SeleniumASTVisitor ) l line_count ( Scanner ) lambda ( lex_rule ) p position ( Scanner ) r rules ( Scanner ) regex ( lex_rule ) s state ( CheckNode ) scanner ( parser ) t tests ( AST ) token ( Scanner , parser ) testName ( TestNode ) tree ( parser ) u url ( VisitNode ) y yyinput ( Scanner ) yytext ( Scanner )","title":"Class Member Variables"},{"location":"compiler/class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"compiler/class_member_variables/#a","text":"actions ( TestNode )","title":"a"},{"location":"compiler/class_member_variables/#c","text":"content ( TypeNode )","title":"c"},{"location":"compiler/class_member_variables/#d","text":"description ( CheckNode , ClickNode , TypeNode )","title":"d"},{"location":"compiler/class_member_variables/#e","text":"element_type ( CheckNode , ClickNode , TypeNode ) errors ( parser )","title":"e"},{"location":"compiler/class_member_variables/#k","text":"keep_xpath ( SeleniumASTVisitor )","title":"k"},{"location":"compiler/class_member_variables/#l","text":"line_count ( Scanner ) lambda ( lex_rule )","title":"l"},{"location":"compiler/class_member_variables/#p","text":"position ( Scanner )","title":"p"},{"location":"compiler/class_member_variables/#r","text":"rules ( Scanner ) regex ( lex_rule )","title":"r"},{"location":"compiler/class_member_variables/#s","text":"state ( CheckNode ) scanner ( parser )","title":"s"},{"location":"compiler/class_member_variables/#t","text":"tests ( AST ) token ( Scanner , parser ) testName ( TestNode ) tree ( parser )","title":"t"},{"location":"compiler/class_member_variables/#u","text":"url ( VisitNode )","title":"u"},{"location":"compiler/class_member_variables/#y","text":"yyinput ( Scanner ) yytext ( Scanner )","title":"y"},{"location":"compiler/class_member_typedefs/","text":"Class Member Typedefs Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"compiler/class_member_typedefs/#class-member-typedefs","text":"Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"compiler/class_member_enums/","text":"Class Member Enums Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"compiler/class_member_enums/#class-member-enums","text":"Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"compiler/namespace_members/","text":"Namespace Members Nothing related to Namespace Members found.","title":"Namespace Members"},{"location":"compiler/namespace_members/#namespace-members","text":"Nothing related to Namespace Members found.","title":"Namespace Members"},{"location":"compiler/namespace_member_functions/","text":"Namespace Member Functions Nothing related to Namespace Member Functions found.","title":"Namespace Member Functions"},{"location":"compiler/namespace_member_functions/#namespace-member-functions","text":"Nothing related to Namespace Member Functions found.","title":"Namespace Member Functions"},{"location":"compiler/namespace_member_variables/","text":"Namespace Member Variables Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"compiler/namespace_member_variables/#namespace-member-variables","text":"Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"compiler/namespace_member_typedefs/","text":"Namespace Member Typedefs Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"compiler/namespace_member_typedefs/#namespace-member-typedefs","text":"Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"compiler/namespace_member_enums/","text":"Namespace Member Enums Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"compiler/namespace_member_enums/#namespace-member-enums","text":"Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"compiler/functions/","text":"Functions Nothing related to Functions found.","title":"Functions"},{"location":"compiler/functions/#functions","text":"Nothing related to Functions found.","title":"Functions"},{"location":"compiler/macros/","text":"Macros Nothing related to Macros found.","title":"Macros"},{"location":"compiler/macros/#macros","text":"Nothing related to Macros found.","title":"Macros"},{"location":"compiler/variables/","text":"Variables j json ( JsonASTVisitor.cpp ) t Tokens ( scanner.h ) y yysval ( scanner.cpp , scanner.h )","title":"Variables"},{"location":"compiler/variables/#variables","text":"","title":"Variables"},{"location":"compiler/variables/#j","text":"json ( JsonASTVisitor.cpp )","title":"j"},{"location":"compiler/variables/#t","text":"Tokens ( scanner.h )","title":"t"},{"location":"compiler/variables/#y","text":"yysval ( scanner.cpp , scanner.h )","title":"y"},{"location":"compiler/links/","text":"Related Pages Modules Class List Namespace ListNamespace List Namespace Members Namespace Member Functions Namespace Member Variables Namespace Member Typedefs Namespace Member Enumerations Class Index Class Hierarchy Class Members Class Member Functions Class Member Variables Class Member Typedefs Class Member Enumerations Files File Variables File Functions File Macros","title":"Links"}]}